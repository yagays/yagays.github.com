<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Wolfeyes Bioinformatics beta]]></title>
  <link href="http://yagays.github.io/atom.xml" rel="self"/>
  <link href="http://yagays.github.io/"/>
  <updated>2013-06-25T10:05:38+09:00</updated>
  <id>http://yagays.github.io/</id>
  <author>
    <name><![CDATA[yag_ays]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[BioPythonで塩基配列をアミノ酸配列にする]]></title>
    <link href="http://yagays.github.io/blog/2013/06/25/biopython-translation/"/>
    <updated>2013-06-25T09:59:00+09:00</updated>
    <id>http://yagays.github.io/blog/2013/06/25/biopython-translation</id>
    <content type="html"><![CDATA[<h3>BioPython</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">mRNA</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;TATGAAAGT&quot;</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">mRNA</span><span class="o">.</span><span class="n">translate</span><span class="p">()</span>
</span><span class='line'><span class="n">Seq</span><span class="p">(</span><span class="s">&#39;YES&#39;</span><span class="p">,</span> <span class="n">ExtendedIUPACProtein</span><span class="p">())</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Why Biopython?</h3>

<p><a href="http://xkcd.com/353/">xkcd: Python</a>
<img src="http://imgs.xkcd.com/comics/python.png" alt="" /></p>

<h3>Ref.</h3>

<ul>
<li><a href="http://biopython.org/DIST/docs/tutorial/Tutorial.html">Biopython Tutorial and Cookbook</a></li>
<li><p><a href="http://yagays.github.io/blog/2013/04/20/install-biopython/">Mac OS Xで手っ取り早くBiopythonをインストールして使えるようにする - Wolfeyes Bioinformatics beta</a></p></li>
<li><p><a href="http://insectcell.exblog.jp/20703555/">awkとsedで塩基配列をアミノ酸配列にする : したっぱ昆虫細胞研究者のメモ</a></p></li>
<li><a href="https://twitter.com/chalkless/status/349052297982132225">Twitter / chalkless: @n0rr $ perl -MBio::Seq -le &#8230;</a></li>
<li><a href="https://twitter.com/dritoshi/status/349056205160841216">Twitter / dritoshi: @chalkless @n0rr &#8230;</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2013 Web Server issue]]></title>
    <link href="http://yagays.github.io/blog/2013/06/24/nar-web-server-issue-2013/"/>
    <updated>2013-06-24T14:20:00+09:00</updated>
    <id>http://yagays.github.io/blog/2013/06/24/nar-web-server-issue-2013</id>
    <content type="html"><![CDATA[<p><a href="http://nar.oxfordjournals.org/content/41/W1.toc" target="_blank"><img src="http://dl.dropboxusercontent.com/u/142306/b/W1.cover.gif" align="right" alt="http://nar.oxfordjournals.org/content/41/W1.cover-expansion"></a></p>

<p>今年のWeb Server issue 2013が既に閲覧できるようになっていた．</p>

<p><a href="http://nar.oxfordjournals.org/">Nucleic Acid Research誌</a>は少し特殊な特別号を毎年出していて，1月にはDatabase issueが，7月にはWeb Server issueが発刊されるのが定番になっている．これらの特集号は，他の論文誌では論文になりにくいようなデータベース構築やウェブサービス系を論文として発表する場として，バイオインフォ系にとっては重要な投稿先の一つといえる．特に，ウェブサービスのアップデートなども同様の投稿ができるようになっており，新規性としては少し弱いウェブサービスの保守管理や機能追加に関しても評価されるのが大きな特徴だ（ただし2年間のインターバルが必要）．</p>

<p><strong>今年のWeb Server issue：<a href="http://nar.oxfordjournals.org/content/41/W1.toc">Table of Contents — 1 July 2013, 41 (W1)</a></strong></p>

<p>今年は合計で95本のウェブサービスに関する論文が採択されたようだ．Editorialによると</p>

<blockquote><p>For the 2013 issue, 293 summaries were submitted and 129, or 44%, were approved for manuscript submission. Of those approved, 95, or 73%, were ultimately accepted for publication.</p>

<p><a href="http://nar.oxfordjournals.org/content/41/W1/W1.full">http://nar.oxfordjournals.org/content/41/W1/W1.full</a></p></blockquote>

<p>ということで，293本の投稿のうち最終的に95本が採択され，全体で見れば約32%の採択率となっている．</p>

<br/>


<p>来年のWeb Server Issue 2014の締め切りは今年いっぱいまで(31 Dec. 2013)となっている．それまでに完全に動くウェブサービスと1ページのproposalを書いて投稿し，そこで通れば1ヶ月でmanuscriptを書いて7月に掲載という流れのようだ．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tophatにおいて使用するスレッド数を上げすぎるとファイルディスクリプタの上限でエラーになる]]></title>
    <link href="http://yagays.github.io/blog/2013/06/23/tophat-too-many-open-files/"/>
    <updated>2013-06-23T10:33:00+09:00</updated>
    <id>http://yagays.github.io/blog/2013/06/23/tophat-too-many-open-files</id>
    <content type="html"><![CDATA[<p>久しぶりにTophatをいじったら一発目でエラーで落ちてしまい，出鼻をくじかれてしまった…．原因を調べてみると，どうやらTophatのコマンド実行時に指定する-pオプションの数字を調子に乗って上げすぎたのが良くなかったらしい．といっても計算機のリソースに問題があったわけではなく，ユーザが使えるシステムリソースの制限を超えてしまったために，Tophatが停止してしまったようだ．この問題はTophatの公式サイトのFAQでも取り上げられているが，このBlogでもエラーメッセージとともに原因と対策を書いておこうと思う．</p>

<h3>Tophatの標準エラー出力のメッセージ</h3>

<p>今回の場合は，Tophatのログの最後で以下のようなエラーメッセージが表示される．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[...]
</span><span class='line'>[2013-06-23 00:22:33] Mapping right_kept_reads_seg3 to genome chlamydomonas_236 with Bowtie2 (3/4)
</span><span class='line'>[2013-06-23 00:33:09] Mapping right_kept_reads_seg4 to genome chlamydomonas_236 with Bowtie2 (4/4)
</span><span class='line'>[2013-06-23 00:44:57] Searching for junctions via segment mapping
</span><span class='line'>        [FAILED]
</span><span class='line'>Error: segment-based junction search failed with err =1
</span><span class='line'>Error opening SAM file output/tmp/right_kept_reads_seg1.bam</span></code></pre></td></tr></table></div></figure>


<p>これだけでは何のことだかよくわからないが，Tophatが出力するログのlogs/segment_juncs.logを見ると，このエラーに関してもう少し詳細な記述が出力されている．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    Loading scaffold_53...done
</span><span class='line'>    Loading scaffold_54...done
</span><span class='line'>    Loading ...done
</span><span class='line'>&gt;&gt; Performing segment-search:
</span><span class='line'>Loading left segment hits...
</span><span class='line'>done.
</span><span class='line'>Loading right segment hits...
</span><span class='line'>open: Too many open files
</span><span class='line'>Error opening SAM file output/tmp/right_kept_reads_seg2.bam</span></code></pre></td></tr></table></div></figure>


<p>これを見ると，どうやらsegment_juncsの実行中に「open: Too many open files」が原因で実行が落ちたようだ．</p>

<h3>原因と対策</h3>

<p>このエラーに関しては，実はTophatの公式サイトのFAQに「What should I do if I see a message like &#8220;Too many open files&#8221;?」という，まさに先ほどのエラーメッセージの内容そのままの項がある．</p>

<blockquote><p>This usually happens when using &#8220;-p&#8221; option with a large value (many threads). TopHat may produce many intermediate files, the number of which is proportional to this value; sometimes the number of the files may go over the maximum number of files a process is allowed to open. The solution is to raise the limit to a higher number (e.g. 10000). For Mac, you can change this using a command, &#8220;sudo sysctl -w kern.maxfiles=10240&#8221;.</p>

<p><a href="http://tophat.cbcb.umd.edu/faq.shtml#many_file">TopHat :: Center for Bioinformatics and Computational Biology</a></p></blockquote>

<p>ざっと要約すると「Tophatは中間ファイルを大量に作るから時々許容数超えちゃうんだよね．扱えるファイル数の上限上げるか，Macなら次のコマンドで対処してね」ということになる．さすがにこれだけではよく分からないと思うので，SEQanswersの以下のスレッドも参考にしつつ，もう少し詳しく見ていこうと思う．</p>

<p><a href="http://seqanswers.com/forums/showthread.php?t=21316">Tophat segment junction error 1, invalid BAM binary header - SEQanswers</a></p>

<h3>limitとファイルディスクリプタ数の制限</h3>

<p>さて，公式サイトのFAQにおいてファイル数の上限といった言葉が出てきたように，LinuxやMacではユーザごとに使用することのできる各種システムリソースに制限が設けられている．具体的にはユーザが使用できるCPU数やメモリの容量，プロセスの数などがそれに該当するのだが，その中に<strong>「ファイルディスクリプタ数」</strong>という項目があり，1プロセスが同時に開くことのできるファイル数の上限を定めている．これは主にひとつの計算機を複数人が使用するマルチユーザシステムにおいて，一人がリソースを独占するのを防いだりアプリケーションの暴走を止めたりするのに役立つのだが，今回のような大規模な計算を実行する際にはこれが邪魔になってしまう．</p>

<p>システムリソースの制限を確認したい場合には，「ulimit -a」または「limit」というコマンドを使う．例えば，私の環境では以下のようになる．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># ソフトリミット
</span><span class='line'>$ ulimit -a
</span><span class='line'>-t: cpu time (seconds)              unlimited
</span><span class='line'>-f: file size (blocks)              unlimited
</span><span class='line'>-d: data seg size (kbytes)          unlimited
</span><span class='line'>-s: stack size (kbytes)             8192
</span><span class='line'>-c: core file size (blocks)         0
</span><span class='line'>-m: resident set size (kbytes)      unlimited
</span><span class='line'>-u: processes                       1024
</span><span class='line'>-n: file descriptors                1024
</span><span class='line'>-l: locked-in-memory size (kbytes)  64
</span><span class='line'>-v: address space (kbytes)          unlimited
</span><span class='line'>-x: file locks                      unlimited
</span><span class='line'>-i: pending signals                 127413
</span><span class='line'>-q: bytes in POSIX msg queues       819200
</span><span class='line'>-e: max nice                        0
</span><span class='line'>-r: max rt priority                 0</span></code></pre></td></tr></table></div></figure>


<p>ここで表示されるのは厳密にはソフトリミットと呼ばれ，ユーザごとに設定されている制限である．一方でハードリミットと呼ばれる制限もあり，これは管理者(root)が定める制限となっている．ソフトリミットは，このハードリミットの範囲内でしか自由に制限値を変更することはできない．ハードリミットを確認したい場合には，-Hオプションを付ける．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># ハードリミット
</span><span class='line'>$ ulimit -aH
</span><span class='line'>-t: cpu time (seconds)              unlimited
</span><span class='line'>-f: file size (blocks)              unlimited
</span><span class='line'>-d: data seg size (kbytes)          unlimited
</span><span class='line'>-s: stack size (kbytes)             unlimited
</span><span class='line'>-c: core file size (blocks)         unlimited
</span><span class='line'>-m: resident set size (kbytes)      unlimited
</span><span class='line'>-u: processes                       127413
</span><span class='line'>-n: file descriptors                4096
</span><span class='line'>-l: locked-in-memory size (kbytes)  64
</span><span class='line'>-v: address space (kbytes)          unlimited
</span><span class='line'>-x: file locks                      unlimited
</span><span class='line'>-i: pending signals                 127413
</span><span class='line'>-q: bytes in POSIX msg queues       819200
</span><span class='line'>-e: max nice                        0
</span><span class='line'>-r: max rt priority                 0</span></code></pre></td></tr></table></div></figure>


<p>さて，今回問題になっているファイルディスクリプタ数は「-n: file descriptors」で表示されている．上の例の場合，ソフトリミットでは1024，ハードリミットでは4096となっている．つまり，Tophatは1024個以上のファイルを1スレッドで開こうとしたために，このソフトリミットに引っかかってしまったようだ．</p>

<h3>フィアルディスクリプタ数の制限への対策</h3>

<p>この問題を回避するには主に2つの方法がある．</p>

<p>1．Tophatの-pオプションの値を小さくする</p>

<p>2．ソフトリミットのファイルディスクリプタの値を大きくする</p>

<p>まず1.では，Tophatが使用するスレッド数を少なくすることで，ファイルディスクリプタ数の上限に引っかからなくするというもの．一度-pオプションを無くして実行してみれば，おそらく今回のエラーには引っかからなくなるだろう．一度に開くファイル数が少なくなりほぼ確実に実行できるようにはなるが，並列処理数が減ってしまうのでTophatの実行時間は長くなってしまう．</p>

<p>そこで2.のようにの制限を無くして，-pオプションはそのままにファイルディスクリプタの上限を回避するという方法もある．実行コマンドや実行時間はそのままにエラーを回避することができる一方で，上限を上げたからといってもTophatがそれ以上の同時ファイルオープンをしてしまえば同様のエラーに引っかかってしまうほか，制限を上げたことにより計算機に負荷がかかる恐れもある．つまり，時と場合によっては成功するが確証は無いという感じだろうか．</p>

<p>ちなみに，私の場合はファイルディスクリプタ数を上げても以下のような別のエラーが出て実行できなかった．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Error: ReadStream::getRead() called with out-of-order id#!</span></code></pre></td></tr></table></div></figure>


<p>ということで，結論としてはTophatの実行時間との兼ね合いを考えて，どちらかを選択したほうが良いだろう．素直に-pオプションの値を下げるほうが無難な気がする．</p>

<p>ちなみに，制限値を引き上げるには，ulimitで以下のように値を変更する．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ulimit -n 2000
</span><span class='line'>$ limit
</span><span class='line'>-t: cpu time (seconds)              unlimited
</span><span class='line'>-f: file size (blocks)              unlimited
</span><span class='line'>-d: data seg size (kbytes)          unlimited
</span><span class='line'>-s: stack size (kbytes)             8192
</span><span class='line'>-c: core file size (blocks)         0
</span><span class='line'>-m: resident set size (kbytes)      unlimited
</span><span class='line'>-u: processes                       1024
</span><span class='line'>-n: file descriptors                2000
</span><span class='line'>-l: locked-in-memory size (kbytes)  unlimited
</span><span class='line'>-v: address space (kbytes)          unlimited
</span><span class='line'>-x: file locks                      unlimited
</span><span class='line'>-i: pending signals                 16545839
</span><span class='line'>-q: bytes in POSIX msg queues       819200
</span><span class='line'>-e: max nice                        0
</span><span class='line'>-r: max rt priority                 0</span></code></pre></td></tr></table></div></figure>


<p>ulimitの後ろに該当するパラメータの値を指定することによって，上限を引き上げることができる．ただし，先ほど述べたようにハードリミットより上は指定することができないので注意が必要になる．</p>

<h3>まとめ</h3>

<p>Tophatのエラー「open: Too many open files」は，スレッドが一度に開くことのできるファイルディスクリプタ数がソフトリミットの上限に引っかかってしまったために起こる．-pオプションの値を下げて実行するか，ソフトリミットのファイルディスクリプタの上限を引き上げることによって回避することができる．まずは，-pオプションを指定せずに実行してみよう．</p>

<h4>参考</h4>

<ul>
<li><a href="http://tophat.cbcb.umd.edu/faq.shtml">TopHat :: Center for Bioinformatics and Computational Biology</a></li>
<li><a href="http://seqanswers.com/forums/showthread.php?t=21316">Tophat segment junction error 1, invalid BAM binary header - SEQanswers</a></li>
<li><a href="http://x68000.q-e-d.net/~68user/unix/pickup?limit">UNIXの部屋 コマンド検索:limit (*BSD/Linux)</a></li>
<li><a href="http://yumewaza.yumemi.co.jp/2010/07/limitsconf.html">ファイルディスクリプタ数の上限変更とlimits.confの罠 (ゆめ技：ゆめみスタッフブログ)</a></li>
</ul>


<h4>実行環境</h4>

<ul>
<li>OS：RHEL 6.3</li>
<li>Tophat：v2.0.8b</li>
<li>Bowtie：version 2.1.0</li>
<li>Samtools：0.1.19.0</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRA Toolkitを使ってsraファイルからfastqファイルに変換する(更新版)]]></title>
    <link href="http://yagays.github.io/blog/2013/06/20/fastq-dump-sratoolkit/"/>
    <updated>2013-06-20T11:26:00+09:00</updated>
    <id>http://yagays.github.io/blog/2013/06/20/fastq-dump-sratoolkit</id>
    <content type="html"><![CDATA[<p>久しぶりにfastq-dumpを使ったら少し仕様が変わっていたのでメモ．だいぶ前に別の場所で書いた記事は，既に古くなってしまっている．何もせず記事を放置しておくのも申し訳ないし，どうやらfastq-dumpでググると上位にくるようなので，ここいらで更新しておかないと…．</p>

<p>(deprecated) <a href="http://g86.dbcls.jp/~yag/wordpress/archives/959">Wolf Ears » SRA Toolkitを使ってsraファイルからfastqファイルに変換する</a></p>

<h3>SRA Toolkitのインストール</h3>

<p>sraからfastqに変換するプログラムは，SRA Toolkitの中にあるfastq-dumpを使う．まずはNCBIのサイトからOS環境に合わせてコンパイルされたSRA Toolkitをダウンロードしてインストールする．</p>

<p><a href="http://trace.ncbi.nlm.nih.gov/Traces/sra/sra.cgi?view=software">Software : Software : Sequence Read Archive : NCBI/NLM/NIH</a></p>

<p>コンパイルされたバイナリとしては，Linux系列のCentOSやUbuntu，MacOSやMS Windowsに合わせたものが用意されている．私の環境はRed Hat Enterpriseなので，とりあえず「CentOS Linux 64 bit architecture」を選択する．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ wget http://ftp-trace.ncbi.nlm.nih.gov/sra/sdk/2.3.2-5/sratoolkit.2.3.2-5-centos_linux64.tar.gz
</span><span class='line'>$ tar zxvf sratoolkit.2.3.2-5-centos_linux64.tar.gz </span></code></pre></td></tr></table></div></figure>


<p>今回使用するfastq-dumpは展開したディレクトリのbin以下に入っている．以下のように実行して動作するか確認する．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sratoolkit.2.3.2-5-centos_linux64/bin/fastq-dump
</span><span class='line'>
</span><span class='line'>Usage:
</span><span class='line'>  sratoolkit.2.3.2-5-centos_linux64/bin/fastq-dump [options] &lt;path [path...]&gt;
</span><span class='line'>  sratoolkit.2.3.2-5-centos_linux64/bin/fastq-dump [options] [ -A ] &lt;accession&gt;
</span><span class='line'>
</span><span class='line'>Use option --help for more information
</span><span class='line'>
</span><span class='line'>sratoolkit.2.3.2-5-centos_linux64/bin/fastq-dump : 2.3.2</span></code></pre></td></tr></table></div></figure>


<h3>fastq-dumpの使い方</h3>

<p>基本的な使い方としては，以下のようにfastq-dumpにsraファイルを指定すればよい&#8230;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ fastq-dump ./DRR002191.sra</span></code></pre></td></tr></table></div></figure>


<p>…のだが，ここでひとつ注意が必要になる．上のコマンドを指定すると，データがシングルエンドでもペアエンドでも同様に一つのファイルとして出力されてしまう．実際に変換されたfastqファイルの中身を見てみると，上のDRR002191.sraは本当は90bpのペアエンドなのだが，以下のように結合された配列として出力される．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ head -n 4 DRR002191.fastq
</span><span class='line'>@DRR002191.1 FCD0BMAACXX:5:1101:1133:1889# length=180
</span><span class='line'>NCAATGGCAATAGCAATGCATTGAAATGAAAAGGCATTTACCAGGAGCAGGAAAGCCAGAAAGAGGAGCAGTGNNCNNGGAGTTGCNNNNTGCTTGGCTTCATCTTTTGCAATTCTGCATCTTTTGCATTTCCCTTCTCGCTCTGCTGCTCGCTCGCCTTTCTTNNNCGNCCTTTTCCCC
</span><span class='line'>+DRR002191.1 FCD0BMAACXX:5:1101:1133:1889# length=180
</span><span class='line'>#1=DDFFFHFFHHIIJJJIJJIJJIJBCHHIHGCC&gt;FGIGIHDH?HJIEGEGI@FEHIJIIE@HI9=EH=CDD#################B@CFFDDDDFHHHGIJJIJJGGIGJIIHGHIGIJIHIJIEIIHIJJIGGHHEGI@DGCGEFHHIGIEFEFFBCB################</span></code></pre></td></tr></table></div></figure>


<p>ということで，きちんとペアエンドを2つのfastqファイルに変換するには，&#8211;split-filesというオプションを使用する．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ fastq-dump --split-files ./DRR002191.sra</span></code></pre></td></tr></table></div></figure>


<p>これで，きちんと2つのfastqファイルが出力される．個別のfastqファイルを見ると，やはり先程の変換はペアエンドの配列を結合して出力されていることがわかる．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ls *.fastq
</span><span class='line'>DRR002191_1.fastq  DRR002191_2.fastq
</span><span class='line'>
</span><span class='line'>$ head -n 4 DRR002191_1.fastq DRR002191_2.fastq
</span><span class='line'>==&gt; DRR002191_1.fastq &lt;==
</span><span class='line'>@DRR002191.1 FCD0BMAACXX:5:1101:1133:1889# length=90
</span><span class='line'>NCAATGGCAATAGCAATGCATTGAAATGAAAAGGCATTTACCAGGAGCAGGAAAGCCAGAAAGAGGAGCAGTGNNCNNGGAGTTGCNNNN
</span><span class='line'>+DRR002191.1 FCD0BMAACXX:5:1101:1133:1889# length=90
</span><span class='line'>#1=DDFFFHFFHHIIJJJIJJIJJIJBCHHIHGCC&gt;FGIGIHDH?HJIEGEGI@FEHIJIIE@HI9=EH=CDD#################
</span><span class='line'>
</span><span class='line'>==&gt; DRR002191_2.fastq &lt;==
</span><span class='line'>@DRR002191.1 FCD0BMAACXX:5:1101:1133:1889# length=90
</span><span class='line'>TGCTTGGCTTCATCTTTTGCAATTCTGCATCTTTTGCATTTCCCTTCTCGCTCTGCTGCTCGCTCGCCTTTCTTNNNCGNCCTTTTCCCC
</span><span class='line'>+DRR002191.1 FCD0BMAACXX:5:1101:1133:1889# length=90
</span><span class='line'>B@CFFDDDDFHHHGIJJIJJGGIGJIIHGHIGIJIHIJIEIIHIJJIGGHHEGI@DGCGEFHHIGIEFEFFBCB################</span></code></pre></td></tr></table></div></figure>


<h3>その他の注意点</h3>

<p>fastq-dumpに指定するsraファイルは，きちんとパスを指定しないといけないようだ．以下のようなエラーが出る場合は，絶対パスを指定するか，カレントディレクトリにsraファイルがある場合にはファイル名の前に「<strong>./</strong>」を付け加える．</p>

<h4>パスが解決できなくて実行できない例</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ fastq-dump DRR002191.sra
</span><span class='line'>2013-06-20T02:11:42 fastq-dump.2.3.2 err: name not found while resolving tree within virtual file system module - failed to open 'DRR002191.sra'
</span><span class='line'>Written 0 spots total</span></code></pre></td></tr></table></div></figure>


<h4>絶対パスを指定するか./を付け加える</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ fastq-dump /path/to/DRR002191.sra
</span><span class='line'>$ fastq-dump ./DRR002191.sra</span></code></pre></td></tr></table></div></figure>




<br/>


<p>また，他のオプションなどの情報はfastq-dumpのhelpから見ることができる．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ fastq-dump --help
</span><span class='line'>
</span><span class='line'>Usage:
</span><span class='line'>  /home/is/yuki-ok/biolocal/src/sratoolkit.2.3.2-5-centos_linux64/bin/fastq-dump [options] &lt;path [path...]&gt;
</span><span class='line'>  /home/is/yuki-ok/biolocal/src/sratoolkit.2.3.2-5-centos_linux64/bin/fastq-dump [options] [ -A ] &lt;accession&gt;
</span><span class='line'>
</span><span class='line'>INPUT
</span><span class='line'>  -A|--accession &lt;accession&gt;       Replaces accession derived from &lt;path&gt; in
</span><span class='line'>                                   filename(s) and deflines (only for single
</span><span class='line'>                                   table dump)
</span><span class='line'>  --table &lt;table-name&gt;             Table name within cSRA object, default is
</span><span class='line'>                                   "SEQUENCE"
</span><span class='line'>
</span><span class='line'>[...]</span></code></pre></td></tr></table></div></figure>


<h4>環境</h4>

<ul>
<li>NCBI SRA Toolkit : May 9 2013, version 2.3.2-5 release</li>
<li>fastq-dump : 2.3.2</li>
</ul>


<h4>参考</h4>

<ul>
<li><a href="http://www.ncbi.nlm.nih.gov/sra/?term=DRR002191">Whole genome resequencing of Masaru Tomita - SRA - NCBI</a></li>
<li><a href="http://trace.ddbj.nig.ac.jp/DRASearch/run?acc=DRR002191">DRR002191 - DRA Search</a></li>
<li><a href="ftp://ftp.ddbj.nig.ac.jp/ddbj_database/dra/fastq/DRA000/DRA000583/DRX001619">/ddbj_database/dra/fastq/DRA000/DRA000583/DRX001619 のインデックス</a> (こちらではまだfastq.bz2で配布されている)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MacPortsで使用していない過去のバージョンのパッケージを消す＆ちょっと可視化]]></title>
    <link href="http://yagays.github.io/blog/2013/06/19/macports-distfile-clean/"/>
    <updated>2013-06-19T04:29:00+09:00</updated>
    <id>http://yagays.github.io/blog/2013/06/19/macports-distfile-clean</id>
    <content type="html"><![CDATA[<p>MacBook Airの128GBしかない非力なSSDもそろそろ満杯になってきた．最近ではスワップが溜まっては再起動するということを繰り返していたので，色々と容量の食っているファイルをちまちま消していた．そういった地道な努力をしつつ無駄なキャッシュや不必要なファイルなどをちゃんと調べてみると，どうやらMacPortsが10GB近く占めていることがわかり，しかもバージョンアップによって使用されなくなったgccやllvm，boostなどの古いバージョンのせいだとわかったので，思い切って消してみることにした．</p>

<h3>古いバージョンのパッケージを消す</h3>

<p>MacPortsでは，バージョンが上がってアップデートする際に，インストールされているバージョンのパッケージをInactiveとし最新バージョンをActiveにするという方法で，過去のバージョンのパッケージが残される仕組みになっている．ということで，Inactiveなパッケージを全て消去するために，以下のコマンドを使用する．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo port -u uninstall</span></code></pre></td></tr></table></div></figure>


<p>これでInactiveなパッケージを全て消去することができる．なお，古いバージョンとして残っていたパッケージを消すということは気軽にバージョンを変更したりできなくなるということなので，もしバージョンアップによる不具合に対応する必要が出てくると後々面倒になることを注意しておきたい．</p>

<h3>結果</h3>

<p><strong>/opt/localが10GBから5GB</strong>になり，かなりのダイエットに成功した！容量の少ないMacBook Airでも，これでもうちょっと耐えられそう．</p>

<h3>DaisyDiskによる可視化</h3>

<p>さて，ここからは完全に蛇足なのだが，最近使用しているのDaisyDiskという可視化ソフトウェアがなかなか気に入っているので，今回のファイル消去の前後で/opt/localがどれだけ変化するかを確かめてみた．DaisyDiskは本来はインタラクティブに操作することができて，気になる箇所をクリックしたりして拡大することができるのだが，今回は前後の画像比較だけとなっている．使い心地が気になる人は以下のリンクから公式ページに飛んで紹介動画を見ていただきたい．</p>

<p><a href="http://www.daisydiskapp.com/">DaisyDisk - Analyze disk usage and free up disk space on Mac</a></p>

<h4>Before</h4>

<p><img src="http://dl.dropboxusercontent.com/u/142306/b/macports_before.png" alt="" /></p>

<h4>After</h4>

<p><img src="http://dl.dropboxusercontent.com/u/142306/b/macports_after.png" alt="" /></p>

<p>まず全体の容量が10GBから5GBに変わっており，それぞれの面積は単純に割合を示していることに注意．Inactiveなパッケージを消去する前は少数の比較的大きな領域がいくつも見られる．具体的には，左側の外縁から2つ目のピンクの領域がgccやllvm，boost，emacsなどのパッケージのディレクトリを表しており，一番外縁にある灰色がそれぞれのパッケージのファイルになっている．一つのパッケージに複数の灰色で区切られた細かいディレクトリが含まれているのは，それだけアップデートして古いバージョンのパッケージが溜まっていったからだ．そしてInactiveなパッケージを消去した後は，複数の小さな領域が組み合わさっていることがわかり，それぞれのパッケージに含まれるファイルの容量が小さくなったことを示している．</p>

<h4>参考</h4>

<ul>
<li><a href="http://guide.macports.org/">MacPorts Guide</a></li>
<li><a href="http://d.hatena.ne.jp/kanonji/20091025/1256495516">MacPortsをちゃんと使うために調べてみた - kanonjiの日記</a></li>
<li><a href="http://d.hatena.ne.jp/t_mimori/20101020/1287568644">Macでディスク容量が足りなくなってきたら1【portをcleanしよう】 - En blanc et noir</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[スライドメモ："Differential expression analysis of de novo assembled transcriptomes - Nadia Davidson"]]></title>
    <link href="http://yagays.github.io/blog/2013/06/18/slide-diffexp-denovo-assembled-transcriptomes/"/>
    <updated>2013-06-18T13:43:00+09:00</updated>
    <id>http://yagays.github.io/blog/2013/06/18/slide-diffexp-denovo-assembled-transcriptomes</id>
    <content type="html"><![CDATA[<p>de novoトランスクリプトームアセンブリに関して配列クラスタリングを解説しているスライドがあったので，ちょっと読んで大まかな流れを追ってみた．ただし後半のクラスタリングの具体的な部分は少し割愛しているほか，内容の正確性は保証できないので注意．</p>

<h2>de novoトランスクリプトームアセンブリの発現差異解析</h2>

<iframe src="http://www.slideshare.net/slideshow/embed_code/18507979?rel=0" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen webkitallowfullscreen mozallowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"> <strong> <a href="http://www.slideshare.net/AustralianBioinformatics/differential-expression-analysis-of-de-novo-assembled-transcriptomes" title="Differential expression analysis of de novo assembled transcriptomes - Nadia Davidson" target="_blank">Differential expression analysis of de novo assembled transcriptomes - Nadia Davidson</a> </strong> from <strong><a href="http://www.slideshare.net/AustralianBioinformatics" target="_blank">Australian Bioinformatics Network</a></strong> </div></p>

<h4>非モデル生物におけるRNA-Seq</h4>

<ul>
<li>非モデル生物におけるRNA-Seq；トランスクリプトームのde novoアセンブル

<ul>
<li>ゲノムアノテーションやゲノム配列が無い状態での解析</li>
</ul>
</li>
</ul>


<h4>トランスクリプトームアセンブラ</h4>

<p>ゲノムアセンブリにおいてはカバレッジに合わせてk-merの長さを最適化していたが，トランスクリプトームアセンブリでは遺伝子ごとに発現量が違うためカバレッジに大きな幅がある</p>

<ul>
<li>解決方法1：ゲノムアセンブラを使って異なるk-merのアセンブル結果を組み合わせる

<ul>
<li><a href="http://www.bcgsc.ca/platform/bioinfo/software/trans-abyss">Trans-ABySS</a>や<a href="http://www.ebi.ac.uk/~zerbino/oases/">Oases</a></li>
</ul>
</li>
<li>解決方法2：トランスクリプトームに特化したアセンブラで単一のk-merでアセンブルする

<ul>
<li><a href="http://trinityrnaseq.sourceforge.net/">Trinity</a></li>
</ul>
</li>
</ul>


<h4>リード数の増加によるアセンブル配列の増加</h4>

<p>横軸がNGSで得られたリード数，縦軸がアセンブルされた配列数を表しており，データ数が増加するにしたがってアセンブルされる配列数も線形に増加する．</p>

<p>スライドでは著者名が間違っているが，ここで引用している図は以下の論文のもの．</p>

<blockquote><p>Francis, W. R. et al. A comparison across non-model animals suggests an optimal sequencing depth for de novo transcriptome assembly. BMC Genomics 14, 167 (2013).</p>

<p><a href="http://www.biomedcentral.com/1471-2164/14/167">http://www.biomedcentral.com/1471-2164/14/167</a></p></blockquote>

<p>余談だが，この論文によるとデータ数が増加するとアセンブルされた配列数が増えるものの，アセンブルされた配列の平均長やN50は途中でサチることが確認されている．この論文の結論としてはデータ数は20M〜30M付近で十分だよねという感じらしい．</p>

<h4>De Bruijn Graphの複雑性</h4>

<p>シーケンスエラーやヘテロ接合箇所などの僅かな配列の違いも異なる配列として出力</p>

<h4>カバレッジの変動</h4>

<p>単一遺伝子内でNGSのショートリードのカバレッジに差があると，複数本の細切れの配列になってしまうことがある</p>

<h4>アイソフォーム単位で発現解析するか遺伝子単位で発現解析するか？</h4>

<ul>
<li>アイソフォーム単位

<ul>
<li>扱う配列が多くなるので大変</li>
<li>発現量解析のときに複数箇所にマッピングされる配列が生じるので発現量推定が大変</li>
<li>全ての転写物に関してアイソフォームがあるわけではない</li>
</ul>
</li>
<li>遺伝子単位

<ul>
<li>スプライシングなどを無視することになる</li>
<li>どうやって複数の転写物を幾つかの遺伝子にまとめるのか？</li>
</ul>
</li>
</ul>


<h4>どうやってアセンブルされた転写物を遺伝子単位にクラスタリングするのか</h4>

<p>アセンブルされた転写物のクラスタリングにおいて決定打は無いものの，幾つか方法はある（配列で共通している箇所を見つけてクラスタリングするとか）</p>

<h4>クラスタリングする際に使える情報</h4>

<ul>
<li>アセンブルする際に出力されるlocus/componentの情報</li>
<li>CD-HITやBlastclustなどの配列相同性によるクラスタリングツール</li>
</ul>


<h4>クラスタリングにはTP・TN・FP・FNを数えて適合率Precisionや再現率Recallを見る</h4>

<p>どうやらTrinityのクラスタリングは良くて，OasesとCD-HIT-ESTの組み合わせは良くないらしい（Trinity&#8217;s clusteringはRSEMのこと？）</p>

<ul>
<li>CD-HIT-ESTは適合率は高いが再現率は低い

<ul>
<li>配列情報しか使用しないので精度が低い</li>
</ul>
</li>
<li>考えられる他の方法

<ul>
<li>発現量が低い領域は重みを軽くしたい</li>
<li>サンプル間で発現量の違う配列は区別したい</li>
<li>ペアエンドリードを考慮したい</li>
</ul>
</li>
</ul>


<h4>(クラスタリングの具体的な部分は省略)</h4>

<h4>どのようにしてリード数から発現量に変換するのか</h4>

<ul>
<li>TrinityやOasesが推奨する方法

<ul>
<li>アセンブルされた配列に対してマッピング（複数箇所にマップされてもいい）</li>
<li>複数箇所にマップされた配列も考慮して発現量を求めるプログラムを使う(RSEMとか)</li>
</ul>
</li>
</ul>


<p>実際に行われている方法としてよくあるのは，一番長くアセンブルされた配列に代表させてマッピングして発現量を推定するというもの</p>

<h4>まとめ</h4>

<ul>
<li><strong>Q1. なんでそんなにアセンブルされた転写物が出てくるの？</strong>

<ul>
<li>既にアノテーションされている転写物よりも多くアセンブルされるから</li>
<li>de novoトランスクリプトームアセンブリはそもそも難しいから（完全長のアセンブリは目指しているのだけれども）</li>
<li>インタージェニックやノンコーティングの転写物も多くでてくるから</li>
</ul>
</li>
<li><strong>Q2. アイソフォーム単位か遺伝子単位か</strong>

<ul>
<li>遺伝子単位の方がアイソフォーム単位より良さそう</li>
</ul>
</li>
<li><strong>Q3. どうやってアセンブルされた転写物から遺伝子にクラスタリングするか</strong>

<ul>
<li>Trinityのクラスタリングは良くて，OasesとCD-HIT-ESTの組み合わせは良くない</li>
</ul>
</li>
<li><strong>Q4. どのようにしてリード数から発現量に変換するのか</strong>

<ul>
<li>3つの異なる方法で検証したが似た結果を示した</li>
<li>正確なクラスタリングによる結果を得るほうが他のパイプラインを使って発現量差異を見るほうがインパクトがある（と主張している）</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[「知の逆転」読了]]></title>
    <link href="http://yagays.github.io/blog/2013/06/02/review-interview-and-intelligence/"/>
    <updated>2013-06-02T11:20:00+09:00</updated>
    <id>http://yagays.github.io/blog/2013/06/02/review-interview-and-intelligence</id>
    <content type="html"><![CDATA[<iframe src="http://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=yagays-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=4140883952" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" align="right"></iframe>


<p>すごい人たちに自分のことについて話して貰いたいという欲求は，ある意味下世話な心理でありながら，インタビューという対話の一つの特徴でもある．それが現在も第一線で活躍し続ける研究者であれば，なおさら気になるものだ．本書「知の逆転」は，著名な学者6人のインタビューをまとめた本であり，執筆した本や今までの研究内容と絡めながら現在の主張を分かりやすく簡潔に追いかける内容となっている．聞き手が日本人であることも影響してか，所々に日本に関連した意見も見られる．彼らがどのように世界を捉え，そして日本を見ているのかを垣間見ることができるちょっと変わった面白い本でもある．</p>

<p>本書でインタビューに応じている人物は，</p>

<ul>
<li>「<a href="http://www.amazon.co.jp/gp/product/4794218788/ref=as_li_ss_tl?ie=UTF8&camp=247&creative=7399&creativeASIN=4794218788&linkCode=as2&tag=yagays-22">銃・病原菌・鉄</a><img src="http://www.assoc-amazon.jp/e/ir?t=yagays-22&l=as2&o=9&a=4794218788" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />」の<strong>ジャレド・ダイアモンド</strong></li>
<li>「<a href="http://www.amazon.co.jp/gp/product/400600253X/ref=as_li_ss_tl?ie=UTF8&camp=247&creative=7399&creativeASIN=400600253X&linkCode=as2&tag=yagays-22">生成文法の企て</a><img src="http://www.assoc-amazon.jp/e/ir?t=yagays-22&l=as2&o=9&a=400600253X" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />」の<strong>ノーム・チョムスキー</strong></li>
<li>「<a href="http://www.amazon.co.jp/gp/product/415050251X/ref=as_li_ss_tl?ie=UTF8&camp=247&creative=7399&creativeASIN=415050251X&linkCode=as2&tag=yagays-22">火星の人類学者</a><img src="http://www.assoc-amazon.jp/e/ir?t=yagays-22&l=as2&o=9&a=415050251X" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />」の<strong>オリバー・サックス</strong></li>
<li>「<a href="http://www.amazon.co.jp/gp/product/4782800541/ref=as_li_ss_tl?ie=UTF8&camp=247&creative=7399&creativeASIN=4782800541&linkCode=as2&tag=yagays-22">心の社会</a><img src="http://www.assoc-amazon.jp/e/ir?t=yagays-22&l=as2&o=9&a=4782800541" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />」の<strong>マービン・ミンスキー</strong></li>
<li><a href="http://www.akamai.com/">Akamai</a>創設者でCEOの<strong>トム・レイトン</strong></li>
<li>「<a href="http://www.amazon.co.jp/gp/product/4062577925/ref=as_li_ss_tl?ie=UTF8&camp=247&creative=7399&creativeASIN=4062577925&linkCode=as2&tag=yagays-22">二重らせん</a><img src="http://www.assoc-amazon.jp/e/ir?t=yagays-22&l=as2&o=9&a=4062577925" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />」の<strong>ジェームズ・ワトソン</strong></li>
</ul>


<p>と，知っている人ならばこちらが萎縮してしまうなほどの豪華な面々だ．それぞれが自分の研究分野を開拓し，その後の著作や起業，数々の科学への貢献を経て一般にも認識されうる人物ばかりである．その彼らがインタビューを通して語るのは，もちろん今まで積み上げてきた研究成果でありながら，同時にこれからの未来を予想し「今現在」の世界に向けた提言でもある．</p>

<p>本書は，そのような彼らを知らない人にピッタリの入門書でもあると同時に，たとえ著作を読んだことのある人にとっても十分に興味深い内容となっている．とにかく上で述べた名前に心当たりがあるなら，本書はまさにオススメだ．自分から見てもかなりミーハーな精神だとは思うが，それに足る並びではないだろうか．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[段落の冒頭に強い接続語を使ってはいけない…?]]></title>
    <link href="http://yagays.github.io/blog/2013/06/01/paragraph-heading/"/>
    <updated>2013-06-01T10:57:00+09:00</updated>
    <id>http://yagays.github.io/blog/2013/06/01/paragraph-heading</id>
    <content type="html"><![CDATA[<p>ここ1週間ほどご無沙汰だったので，最近考えているをちょっと書きだしてみる．</p>

<p>最近は同じ研究室の院生の学振書類を手伝ったり，大学院入学希望者の小論文にアドバイスしたりと，人の書いた文書にひたすら赤を入れる日々だったのだが，やはり添削というのは難しい．まず第一には文章を書いた人間の意図を最大限汲み取り，一方では段落や文章の流れを整え単語の使い方を統一するためにバッサバッサとメスを入れ，原形をとどめつつも改善策を提示していかなければならない．ハッキリと論理的に指摘できる部分もあれば，「この言葉の使い方はなんかダサい」みたいな主観的な意見が入ることもある．個人的には徹底して型にはめて形式化された文章にすべきだというスタンスなのだが，逆に書き手の意図さえ伝われば，たとえ文章が全部ひとつなぎになっていようが口語的口調であったり文学的口調になっていようがそれでもいいという人も中にはいるわけで，あまり押し付けがましいのも良くないかなと思う．そして何より，添削しているお前の書く文章はどうなんだと言い返されそうで，自分のやっていることが本当に正しいのかどうか怪しいのが一番怖い．</p>

<p>まあこんなコトを思いつつも，やってくれと言われれば無慈悲に赤を入れるわけだけれども，たまたま見つけた修論の指導を目的とした配布資料にナルホドと思いつつも少し引っかかることが書いてあったので，ここで紹介する．</p>

<p><a href="http://www-utheal.phys.s.u-tokyo.ac.jp/~maxima/NetEd/To_M2/To_M2.pdf">http://www-utheal.phys.s.u-tokyo.ac.jp/~maxima/NetEd/To_M2/To_M2.pdf</a></p>

<p>この中の「2.2 段落（paragraph）」は非常によくまとまっている．英語では特にパラグラフ・リーディングなどで紹介されることが多い段落の構成法は，文章を書く上で何より意識しなければいけない「決まり事」だ．私も文章をあらかた書いたあとに形を整える作業をする際には，このような体裁に特に気をつけている．</p>

<p>この資料では段落を作る上でやって良いこと悪いことといった約束がいくつか紹介されており，それらは納得のいくものばかりなのだが，その中で一つ気になる項目があった．それは「段落の冒頭に強い接続語を使ってはいけない」という部分で，前後の文章を強く結ぶ言葉は段落の冒頭に使うにはふさわしくないということらしい．これに関しては確かに納得のいく部分もある反面，本当に使ってはいけないと断言してしまっていいのだろうかという感覚もある．特に逆接は禁止するほど悪い方法ではないと個人的に思っていて，前の話題にかぶせる形で議論の対象を変えるのに便利に使っている節がある．おそらくこの使い方は段落をひとまとまりとしてみた時の列挙に近い感覚なので，それは確かに段落に分けるべきではないかもしれない．しかしながら，あまりに膨らんだ内容を無理矢理一つに詰め込むのも良くないので，何かしらの方法で分けるべきだとは思う．やはりそこは，逆接を使わずにいきなり新しい話題でスタートしつつ，ところどころに前の段落との関連をいれていくべきなのだろうか．その方法もできなくはないけど，別に逆接を使ってもいいんじゃない？と思ってしまう．具体例が無い状態でアレコレ言うのは生産性が無いというのは分かっていても，なんとなく気になっている．</p>

<p>以上のようなことをこの1週間の間ぼやーっと考えていたわけだけれども，いまだに結論は出ていない．型にはまった文章を書くというのは，読み手が想定する文章を提示することであって，それは論理構造や正確さ以上に読みやすさという重要な役割を果たしていると思っているのだが，読みやすさの感覚は人それぞれなので，なかなかに統一が難しい．</p>

<br/>


<p>（余談）それにしても，ここの文章はどういうアレで書けばいいのか未だによく分からない．表現の境界線を行ったり来たりという感じで，まあ実験場のようなイメージなので，ここで下手糞な文章を書いてても勘弁して欲しい…．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA["The Elements of Statistical Learning"のpdfの余白を削る]]></title>
    <link href="http://yagays.github.io/blog/2013/05/22/esl-pdf-trimming/"/>
    <updated>2013-05-22T09:22:00+09:00</updated>
    <id>http://yagays.github.io/blog/2013/05/22/esl-pdf-trimming</id>
    <content type="html"><![CDATA[<iframe src="http://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=yagays-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=0387848576" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" align="right"></iframe>


<p>機械学習系の教科書としてはそこそこの知名度のある「The Elements of Statistical Learning」（通称ESLまたはHastie）は，全ページのPDFが公式で配布されている．</p>

<p><a href="http://www-stat.stanford.edu/~tibs/ElemStatLearn/">Elements of Statistical Learning: data mining, inference, and prediction. 2nd Edition.</a></p>

<p>これは輪講に使えそうだということで色々と準備をしているのだが，このpdfには一つ気になるところがあって，それはページの余白が大きいということだ．右上にトンボの一部と「Printer: Opaque this」という文字が書かれているように，おそらく印刷所に出す前のpdfをそのまま配布しているらしい．pdfが配布されているだけ有難いというものではあるものの，このままでは少し読みづらい．ということで，余白を良い感じに自動で削れるツールを探して，文字だけの部分を抜き出してみた．</p>

<h3>brissで余白をトリミングする</h3>

<p>今回は「briss」というJavaアプリケーションを使ってみる．</p>

<p><a href="http://appdrill.net/61580/briss.html">[Mac] 自炊に！PDFのページを重ねて一発で余白を切り取る「briss」 « Appdrill</a></p>

<p>使い方は上のリンクを参考にしていただくとして，pdfを読み込んだ画面が以下のようになる．</p>

<p><img src="http://dl.dropboxusercontent.com/u/142306/b/briss1.png" alt="" /></p>

<p>これは1ページ目だけを除いた残りのページを全て重ねあわせたたもので，右ページ中央に表示されているグチャッとした部分がpdfのテキスト部分となる．水色の透過の部分がトリミング後に残る箇所を表しており，読み込んだ際に自動で設定される．左上と右下の四角をドラッグすると範囲を手動で選択できるが，下手にやると右ページと左ページでpdfサイズがズレることがあるので，今回のESLのpdfの場合は自動で設定されたものをそのまま使った方がいいだろう．</p>

<p>トリミングを実行して出力されたpdfを開くと，このような感じになる．</p>

<p><img src="http://dl.dropboxusercontent.com/u/142306/b/briss2.png" alt="" /></p>

<p>今回の場合は本当に文字ぎりぎりという感じだが，iPadで眺めたり印刷する際にはちょうどくらいだ．これでストレス無くESLを読む事ができる．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[treeを使ってディレクトリ構造をターミナル上で可視化する]]></title>
    <link href="http://yagays.github.io/blog/2013/05/21/tree/"/>
    <updated>2013-05-21T14:30:00+09:00</updated>
    <id>http://yagays.github.io/blog/2013/05/21/tree</id>
    <content type="html"><![CDATA[<p>最近は色々と忙しくネタが無いわけではないが，書けるだけの内容にまとまりきれていないのが現状．というわけで今回もLinxuの環境周りの話ということで，ディレクトリ構造をターミナル上で可視化するtreeというコマンドについて．ああ，これ以上何も言うことがない…．</p>

<p><a href="http://mama.indstate.edu/users/ice/tree/">The Tree Command for Linux Homepage</a></p>

<h3>インストール</h3>

<p>ソースを取ってきてコンパイルする．以上．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ wget ftp://mama.indstate.edu/linux/tree/tree-1.6.0.tgz
</span><span class='line'>$ tar zxvf lftp-4.4.6.tar.gz
</span><span class='line'>$ cd tree-1.6.0
</span><span class='line'>$ make</span></code></pre></td></tr></table></div></figure>


<p>あとは，treeをパスの通ったところに移動させれば完了．以上．</p>

<h3>使い方</h3>

<p>何もオプションを指定しないと，以下のようにファイルとディレクトリが表示される．以上．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ tree
</span><span class='line'>.
</span><span class='line'>├── CHANGES
</span><span class='line'>├── INSTALL
</span><span class='line'>├── LICENSE
</span><span class='line'>├── Makefile
</span><span class='line'>├── README
</span><span class='line'>├── TODO
</span><span class='line'>├── color.c
</span><span class='line'>├── color.o
</span><span class='line'>├── doc
</span><span class='line'>│   ├── tree.1
</span><span class='line'>│   ├── tree.1.fr
</span><span class='line'>│   └── xml.dtd
</span><span class='line'>├── hash.c
</span><span class='line'>├── hash.o
</span><span class='line'>├── html.c
</span><span class='line'>├── html.o
</span><span class='line'>├── strverscmp.c
</span><span class='line'>├── tree
</span><span class='line'>├── tree.c
</span><span class='line'>├── tree.h
</span><span class='line'>├── tree.o
</span><span class='line'>├── unix.c
</span><span class='line'>├── unix.o
</span><span class='line'>├── xml.c
</span><span class='line'>└── xml.o
</span><span class='line'>
</span><span class='line'>1 directory, 24 files</span></code></pre></td></tr></table></div></figure>


<p>-dオプションをつけると，ディレクトリだけを表示することができる．詳しくはmanで．以上．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ tree -d
</span><span class='line'>.
</span><span class='line'>└── doc
</span><span class='line'>
</span><span class='line'>1 directory</span></code></pre></td></tr></table></div></figure>


<p>ちなみに，色も付きます（ディレクトリと実行ファイル）．以上．お疲れ様でした．</p>

<p><img src="http://dl.dropboxusercontent.com/u/142306/b/tree.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[zaw.zshを使って移動したことのあるディレクトリに一発で飛ぶ]]></title>
    <link href="http://yagays.github.io/blog/2013/05/20/zaw-zsh/"/>
    <updated>2013-05-20T01:47:00+09:00</updated>
    <id>http://yagays.github.io/blog/2013/05/20/zaw-zsh</id>
    <content type="html"><![CDATA[<p>「zsh anything.el-like widget」通称zawは，Emacsのanything.elみたいなインターフェイスでzshを操作できるという拡張プラグインだ．本来は様々な操作に対応しているのだが，とりあえずディレクトリ操作だけでも恐ろしいほどに便利なので，anything.elを知らない人でも導入して損はないと思う．ここでは以下の記事を参考に，zaw.zshの設定をしてみた．</p>

<ul>
<li><a href="https://github.com/zsh-users/zaw">zsh-users/zaw · GitHub</a></li>
<li><a href="http://u7fa9.org/memo/HEAD/archives/2011-02/2011-02-22_1.rst">zsh でも anything.el っぽいの - memo</a></li>
<li><a href="http://shibayu36.hatenablog.com/entry/20120130/1327937835">zaw.zshで最近移動したディレクトリに移動する - $shibayu36->blog;</a></li>
</ul>


<h3>1. zawをダウンロードする</h3>

<p>今回は.zshというディレクトリを$HOME以下に作成して，そこでgit cloneを実行する．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir .zsh
</span><span class='line'>$ cd .zsh
</span><span class='line'>$ git clone git://github.com/zsh-users/zaw.git</span></code></pre></td></tr></table></div></figure>


<h3>2. .zshrcを設定する</h3>

<p>以下の内容を.zshrcに書き込む．sourceでzaw.zshを読み込む部分は，先ほどダウンロードしたzawディレクトリを指定する．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># zaw.zsh
</span><span class='line'># http://shibayu36.hatenablog.com/entry/20120130/1327937835
</span><span class='line'>autoload -Uz chpwd_recent_dirs cdr add-zsh-hook
</span><span class='line'>add-zsh-hook chpwd chpwd_recent_dirs
</span><span class='line'>zstyle ':chpwd:*' recent-dirs-max 5000
</span><span class='line'>zstyle ':chpwd:*' recent-dirs-default yes
</span><span class='line'>zstyle ':completion:*' recent-dirs-insert both
</span><span class='line'>
</span><span class='line'>source /home/yag_ays/.zsh/zaw/zaw.zsh
</span><span class='line'>zstyle ':filter-select' case-insensitive yes # 絞り込みをcase-insensitiveに
</span><span class='line'>bindkey '^@' zaw-cdr # zaw-cdrをbindkey</span></code></pre></td></tr></table></div></figure>


<h3>3. .zshrcを読み込む</h3>

<p>最後に.zshrcを再度読み込んでエラーがでなければ完了．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ source .zshrc</span></code></pre></td></tr></table></div></figure>


<h3>使い方</h3>

<p>C-@（Control-@）を押すと以下のように，直近で移動したディレクトリの一覧が表示される．</p>

<p><img src="http://dl.dropboxusercontent.com/u/142306/b/zaw1.png" alt="" /></p>

<p>この状態でキーワードを入力すると，マッチしたディレクトリだけを選ぶこともできる．深い階層のディレクトリでも名前さえ覚えていれば一発で飛ぶことができるので，非常に便利だ．</p>

<p><img src="http://dl.dropboxusercontent.com/u/142306/b/zaw2.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cpanmのセッティング]]></title>
    <link href="http://yagays.github.io/blog/2013/05/16/cpanm/"/>
    <updated>2013-05-16T12:19:00+09:00</updated>
    <id>http://yagays.github.io/blog/2013/05/16/cpanm</id>
    <content type="html"><![CDATA[<p>PerlでCPANを使うなら，cpanmが便利．ライブラリはすべてホームディレクトリ以下に展開されるので，管理者権限が無くても気軽に使用できる．</p>

<ul>
<li><a href="http://search.cpan.org/~miyagawa/App-cpanminus-1.6914/bin/cpanm">cpanm - search.cpan.org</a></li>
</ul>


<h3>パスの通ったディレクトリにインストールする</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd local/bin
</span><span class='line'>$ curl -LOk http://xrl.us/cpanm
</span><span class='line'>$ chmod +x cpanm</span></code></pre></td></tr></table></div></figure>


<h3>.zshrcに設定を書き込む</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export PERL_CPANM_OPT="--local-lib=~/.cpanm/"
</span><span class='line'>export PERL5LIB="$HOME/.cpanm/lib/perl5:$PERL5LIB"</span></code></pre></td></tr></table></div></figure>


<h3>例）ライブラリを入れる</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cpanm local::lib
</span><span class='line'>$ cpanm JSON
</span><span class='line'>$ cpanm Cairo</span></code></pre></td></tr></table></div></figure>


<h4>参考</h4>

<ul>
<li><a href="http://www.omakase.org/perl/cpanm.html">perlモジュールのinstallにcpanmを使う｜perl｜@OMAKASE</a></li>
<li><a href="http://g86.dbcls.jp/~yag/wordpress/archives/1400">Wolf Ears » cpanmでBioPerlを入れる</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[アセンブルの指標であるN50とNG50の違い]]></title>
    <link href="http://yagays.github.io/blog/2013/05/15/n50-ng50/"/>
    <updated>2013-05-15T09:42:00+09:00</updated>
    <id>http://yagays.github.io/blog/2013/05/15/n50-ng50</id>
    <content type="html"><![CDATA[<p>今回は配列をアセンブルするときの指標に使うN50とNG50について少しまとめてみようと思う．</p>

<h3>前置き</h3>

<p>アセンブリというのはシーケンサで得られる短い配列から元のゲノム配列を復元する作業のことで，例えるならば膨大な数のジグソーパズルを形を頼りに完成させるとか，シュレッダーに掛けられて短冊になった書類を元に戻す作業といえる．これだけ聞くと頑張ればできそうな気がするが，実際には使える情報はATGCの配列だけと非常に限られており，場所によっては同じ文字が延々と続く箇所があったり，時々文字が間違っていたりと，手作業では不可能に近いし何より計算機を使ったとしても非常に難しい．それに加えて，そもそも元あった状態である解答を誰も知らないので，結果が合っているかどうかも分からず，答え合わせ（評価）がしづらいということがある．</p>

<p>このアセンブリの評価に関しては，Assemblathonというゲノムアセンブラの精度を争うコンペティションで活発に議論されている．というのも，各研究室で開発されたアセンブラの性能に順位を付けるためという以前に，未知のゲノムに対して今までに誰もアセンブル結果の配列だけで評価してこなかったからだ．もう少し正確に言えば，今までのモデル生物のゲノム配列解読は，過去に実験で確かめられてきた膨大な知見のもとで大量の人材と資金を投入して一歩ずつ進められてきた研究であり，現在のスタイルであるNGSを使った非モデル生物のゲノム配列解読のアプローチとはほとんど別物だと言っても過言ではない．そういった経緯があり，現在のAssemblathonではこれからのゲノム配列解読の基準となるような評価手法について，コンペティションを通して試行錯誤が繰り返されている（この話題に関しては<a href="http://www.slideshare.net/kbradnam/assemblathon-2-talk">Assemblathon2のスライド</a>が詳しい）．</p>

<p>ちなみに，Assemblathonは現在，擬似データでアセンブルを競った第1回は終了し論文も出ており，実際の生物データを使った第2回が終了して論文が出るのを待つだけで（<a href="http://arxiv.org/abs/1301.5406">既にArXivに上がっている</a>），第3回も企画されている．</p>

<p>というわけで，ゲノムを読むといっても今までのようにはいかないし，新しい評価も考えつつやっていかないとねという話．その中でスタンダードな評価指標が今回紹介するN50とNG50になる．</p>

<p><img src="http://dl.dropboxusercontent.com/u/142306/b/n50.png" align="right"></p>

<h3>N50</h3>

<p>N50とは一言でいえば配列長の加重平均なのだが，それでは誰も理解してくれないのでもうちょっと噛み砕こう．簡単に言えば，配列を長い順に並べて上から順に足していった時に，全体の長さの半分に達した時の配列の長さ(単位はbp)のことをN50という．イメージだと右図のように，半分の面積になるときの配列の長さがN50となる．得られた配列の分布を見つつ中間くらいの長さを表しているので，長い配列が多いとN50は大きくなるし，逆に長い配列が少なく短い配列が大量にあるとN50は小さくなる．アセンブルの際には復元したいゲノムに少しでも近づけるよう長い配列がたくさん得られると嬉しいので，N50はアセンブルの結果の良し悪しを判断する指標となっている．</p>

<h3>NG50</h3>

<p>とは言うものの，長けりゃそれでいいのかという疑問から出てきたのがNG50という指標だ．アセンブルで得られた配列全体の長さの代わりに，推定されるゲノム配列の長さを使って配列長の平均を計算している．つまり，予想では100Mbpだと推定された生物のゲノムならば，配列を長い順に並べて上から順に足していって100Mbpに達したときの配列の長さをNG50としている．考え方としては，理想となるゲノム配列の長さに近づけるために，長い配列だけじゃなくてある程度短い配列も評価しようということだろう．また，アセンブラの性能を異なるゲノムサイズの生物間で比較する際にも，NG50を用いることで公平に判断することができる．ただし，ゲノムサイズに関しては実験的に求めるかK-merから推定する必要があるので，必ずしも正確かどうかは難しいところがある．</p>

<h3>まとめ</h3>

<p>以上で，ざっとN50とNG50についてまとめてみた．実はこの議論にも続きがあって，NG50だけでは不十分でNG1からNG99までを検討しないといけないという話もある．今回はそこまでは踏み込まないが，気になる人はAssemblathon2の評価手法に関するページを見ていただきたい（<a href="http://assemblathon.org/post/44431933387/assemblathon-2-basic-assembly-metrics">The Assemblathon • Assemblathon 2 basic assembly metrics</a>）．結論としては一概にどの指標がいいかを決めるのは非常に難しいということで，色々と試して見る必要がある．</p>

<h3>参考</h3>

<ul>
<li>(pdf) <a href="http://korflab.ucdavis.edu/datasets/Assemblathon/Assemblathon1/assemblathon_talk.pdf">http://korflab.ucdavis.edu/datasets/Assemblathon/Assemblathon1/assemblathon_talk.pdf</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trinityのインストールとサンプルデータのアセンブル]]></title>
    <link href="http://yagays.github.io/blog/2013/05/14/trinity-install/"/>
    <updated>2013-05-14T21:25:00+09:00</updated>
    <id>http://yagays.github.io/blog/2013/05/14/trinity-install</id>
    <content type="html"><![CDATA[<p>久しぶりに<a href="http://trinityrnaseq.sourceforge.net/">Trinity</a>を触ろうと思ってインストールしたら，実行に<a href="http://bowtie-bio.sourceforge.net/index.shtml">Bowtie</a>が必要になっていた．de novo transcriptome assemblyの後の解析で使う程度かと思いきや，どうやらChrysalis（2段階目）で必要になるらしい．そのため，Bowtieにパスを通していないとTrinity.pl実行時に以下のようなエラーが出る．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Error, cannot find path to bowtie, which is now needed as part of Chrysalis' read scaffolding step at ../../Trinity.pl line 622.</span></code></pre></td></tr></table></div></figure>


<p>というわけで，TrinityのインストールをしつつBowtieも用意して，試しにソースコードに含まれているテストデータの実行をしてみる．</p>

<h3>1. Trinityのインストール</h3>

<p>SourceForgeからソースコードをダウンロードしてインストールする．解凍したディレクトリでmakeをすればよい．</p>

<p><a href="http://sourceforge.net/projects/trinityrnaseq/files/">Trinity RNA-Seq Assembly - Browse Files at SourceForge.net</a></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ wget http://downloads.sourceforge.net/project/trinityrnaseq/trinityrnaseq_r2013-02-25.tgz 
</span><span class='line'>$ tar zxvf trinityrnaseq_r2013-02-25.tgz 
</span><span class='line'>$ cd trinityrnaseq_r2013-02-25
</span><span class='line'>$ make</span></code></pre></td></tr></table></div></figure>


<h3>2. Bowtieのインストール</h3>

<p>こちらも同様にSourceForgeからダウンロードするが，コンパイル済みのバイナリが配布されているので，makeをせずにそのまま利用できる．OSごとに32bit版と64bit版が用意されているので，環境に合わせてダウンロードする．</p>

<p><a href="http://bowtie-bio.sourceforge.net/index.shtml">Bowtie: An ultrafast, memory-efficient short read aligner</a></p>

<p><a href="http://sourceforge.net/projects/bowtie-bio/files/bowtie/1.0.0/">Bowtie - Browse /bowtie/1.0.0 at SourceForge.net</a></p>

<h3>3. Bowtieのバイナリがあるディレクトリにパスを通す</h3>

<p>今回はとりあえずシェルの設定ファイルをいじらずに，コマンドでbowtieがあるディレクトリをパスに指定する．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ export PATH=/Users/yag_ays/Downloads/bowtie-1.0.0:$PATH</span></code></pre></td></tr></table></div></figure>


<p>もし頻繁に使用するなら，bowtieのバイナリをパスが通っている場所に移動させたほうがいいだろう．</p>

<h3>サンプルデータのアセンブル</h3>

<p>ひと通り動くことを確認するために，ソースコードの中に含まれているサンプルデータの解析を動かしてみる．</p>

<p>今回実行するのはsample_data/test_Trinity_Assembly．ディレクトリ内にrunMe.shがあるので，単純にそれを実行すればよい．初回は配列ファイルの解凍が実行されるため，Trinityが実行されるまでに少し時間がかかる．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd sample_data/test_Trinity_Assembly
</span><span class='line'>$ ./runMe.sh</span></code></pre></td></tr></table></div></figure>


<p>もしきちんとパスを通せていれば，標準出力に以下のようなテキストが表示され，解析が始まる．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ../../Trinity.pl --seqType fq --JM 2G --left reads.left.fq --right reads.right.fq --SS_lib_type RF --CPU 4 --no_cleanup --monitoring --output test
</span><span class='line'>WARNING, --monitoring can only be used on linux. Turning it off.
</span><span class='line'>
</span><span class='line'>Current settings:
</span><span class='line'>core file size          (blocks, -c) 0
</span><span class='line'>data seg size           (kbytes, -d) unlimited
</span><span class='line'>file size               (blocks, -f) unlimited
</span><span class='line'>max locked memory       (kbytes, -l) unlimited
</span><span class='line'>max memory size         (kbytes, -m) unlimited
</span><span class='line'>open files                      (-n) 256
</span><span class='line'>pipe size            (512 bytes, -p) 1
</span><span class='line'>stack size              (kbytes, -s) 8192
</span><span class='line'>cpu time               (seconds, -t) unlimited
</span><span class='line'>max user processes              (-u) 709
</span><span class='line'>virtual memory          (kbytes, -v) unlimited
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>Paired mode requires bowtie. Found bowtie at: /Users/yag_ays/Downloads/bowtie-1.0.0/bowtie
</span><span class='line'>
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[「村上式シンプル英語勉強法」読了]]></title>
    <link href="http://yagays.github.io/blog/2013/05/12/review-murakami-english/"/>
    <updated>2013-05-12T09:47:00+09:00</updated>
    <id>http://yagays.github.io/blog/2013/05/12/review-murakami-english</id>
    <content type="html"><![CDATA[<iframe src="http://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=yagays-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=B0081MAET6" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" align="right"></iframe>


<p>英語の勉強法に王道なんてものは無くて，みんながみんな自分の方法を一般論のように語ったり，適当なことを言いふらしてはお金にしようと画策していたり，かく言う僕自身もあまり英語が得意ではない方で勉強法についてもよく分かっていない．だから，勉強しようとすると誰かの意見を盲信するか，自分の流儀を貫き通すしかない．本書も結局は巷にあふれる英語勉強本の中の一つにすぎず，Googleだとか外資社長だとかいった箔が付いている程度のものだ．</p>

<p>本書の主張は非常にシンプルで，英語のスキルを上達させたいなら</p>

<ul>
<li>300万語読む</li>
<li>1万語眺める（覚える）</li>
<li>1000時間聞く</li>
<li>文章を書くときは人の英文を借りてくる</li>
<li>パターンを暗記する</li>
</ul>


<p>をクリアすればいいというもの．あとは，これを実現するために具体的にどうやれば効率が良いかといった方法が，著者自身の経験とともに語られる．例えば，英文を読むときは後戻りをせずに一気に読みきるとか，リスニングは筋トレと同じだから聞き取れないくらいのレベルを聴き続けるとか，英語のメールを書くときは人の文章から借りてくるとか，ちょっとしたコツが幾つも載っている．分量としても，1時間あれば読みきれるくらいなので，軽い気持ちで読み通せる．本書の中では，英語を学習する上で難しいことなんて何も要求されない．</p>

<p>さて，ここまで本書をひと通り読み進めて，あとは内容を信じるか信じないかだ．納得できたかかどうか，信憑性があるかないか，試してみてリスクが大きそうか小さそうか，その辺りが頭のなかを駆け巡ることだろう．僕の場合は，本書の進言をちょっと真面目に聞いてみようかなという気になった．理由なんてものはあってないようなものなのだけれども，著者の英語に対する割り切りの良さが少し気に入ったからかもしれない．</p>

<p>ということで，サクッと読めてアドバイスもそこそこな本書は，意見が合う部分が多く個人的にはオススメできる．まあ，英語上達の保証はできないけれども&#8230;．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA["The Art of How to Train Your Dragon"読了]]></title>
    <link href="http://yagays.github.io/blog/2013/05/09/review-the-art-of-how-to-train-your-dragon/"/>
    <updated>2013-05-09T21:09:00+09:00</updated>
    <id>http://yagays.github.io/blog/2013/05/09/review-the-art-of-how-to-train-your-dragon</id>
    <content type="html"><![CDATA[<iframe src="http://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=yagays-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=1557048630" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" align="right"></iframe>


<p>映画「ヒックとドラゴン」の設定資料集「The Art of How to Train Your Dragon」がようやく届いた！先日書いた<a href="http://yagays.github.io/blog/2013/05/05/toothless-ears/">日記</a>でこの映画に対するテンションの上がり具合は明らかだとは思うが，本書も非常に素晴らしい内容だったので，ここで少し紹介したい．この感動を伝えるには写真で紹介できれば一番なのだが，そこはやはり実際に買ってもらって全編余すところなく楽しんで頂きたい．</p>

<p>マット仕上げのカバーを取ると，黒地に赤いドラゴンのロゴの入ったハードカバーが現れる．全編カラーの本書は，約160ページ程度ながら手に持つと少し重い．本書は映画&#8221;How to Train Your Dragon&#8221;(邦題：『ヒックとドラゴン』)の設定資料集だ．映画の世界観であるヴァイキングとドラゴンが共存する神話的かつ幻想的な世界を，豊富なスケッチとコンセプト画で魅せてくれる．本書は主に，個性豊かなドラゴンのキャラクター画，同じくヴァイキングのキャラクター画，映画の世界観を表現する背景や風景画，そして最後に幾つかの絵コンテと3D画により構成されている．ドラゴンやヴァイキングの設定資料では，映画で登場するキャラクターから映画では見られないボツ作品まで，これでもかというくらい大量の絵やCG作品が収録されている．ちなみに，初期設定ではアスティ(Astrid)のキャラクターはそばかす＆三つ編みだったようだ．コンセプト画からCGモデリングまで，本書では別バージョンのアスティの資料が掲載されている．次に背景や風景画では，バーク島周辺の切り立った山々や深い森の中にある入り江などの壮大な自然が描かれるほか，ヴァイキングの村の細かなディテールも見ることができる．そして最後に絵コンテと3D画の部分では，アーティストが積み上げてきた世界観を3D映画として表現するための，カット割りや一連の動きが紹介される．ここでは3Dのモデリングに関して特に深入りしないものの，ドラゴンの吐く炎の表現であったり3Dにおける光の表現について触れられている．これらの話題はDVDの特典映像でも同様に語られている内容なので，そちらも参考にして頂きたい．</p>

<p>といったように，本書は「ヒックとドラゴン」好きなら必見の内容だろう．たっぷりと収録されているコンセプト画や背景を眺めることで，新たな発見があり，世界観を堪能でき，映画の裏側を覗き見ることができ，そして想像力をかき立てられる素晴らしい設定資料集となっている．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linuxのルートディレクトリ構成まとめ]]></title>
    <link href="http://yagays.github.io/blog/2013/05/06/linux-root-directory/"/>
    <updated>2013-05-06T09:27:00+09:00</updated>
    <id>http://yagays.github.io/blog/2013/05/06/linux-root-directory</id>
    <content type="html"><![CDATA[<ul>
<li><strong>/</strong> # ルートディレクトリ</li>
<li><strong>/vmlinuz</strong> # /bootに置かれているLinuxカーネルにシンボリックリンクが貼られている</li>
<li><strong>/bin/</strong> # バイナリ形式の実行ファイル置き場</li>
<li><strong>/boot/</strong> # Linuxカーネルやブート処理に必要なファイル置き場</li>
<li><strong>/dev/</strong> # デバイスファイル置き場

<ul>
<li><strong>/tty*</strong> # 制御端末に対応している．&#8221;tty&#8221;は&#8221;Teletype&#8221;が由来</li>
<li><strong>/null</strong> # nullデバイス．出力の破棄先に使う</li>
<li><strong>/zero</strong> # zeroデバイス．Nullが延々返ってくる</li>
</ul>
</li>
<li><strong>/etc/</strong> # 設定ファイル置き場

<ul>
<li><strong>/hosts</strong> # ホストとIPの対応付けを行う</li>
<li><strong>/hosts.allow</strong> # 接続を許可するホスト一覧</li>
<li><strong>/hosts.deny</strong> # 接続を拒否するホスト一覧</li>
<li><strong>/passwd</strong> # ユーザの名前やホームディレクトリ一覧</li>
<li><strong>/resolv.conf</strong> # 名前解決のためのDNSサーバ一覧</li>
<li><strong>/shadow</strong> # ユーザのパスワード（暗号化されている）</li>
<li><strong>/rc.local</strong> Linuxの起動時に実行されるシェルスクリプト</li>
<li><strong>/rc?.d/</strong> # 起動用ファイルが置かれるディレクトリ（各ランレベルごとに番号が振られている）</li>
</ul>
</li>
<li><strong>/home/</strong> # ユーザのホームディレクトリ置き場</li>
<li><strong>/lib/</strong> # 共有ライブラリ置き場</li>
<li><strong>/lost+found/</strong> # システム障害時の不明ファイル避難先</li>
<li><strong>/proc/</strong> # プロセスファイスシステム（procfs）置き場．CPUやメモリの情報などが含まれている．

<ul>
<li><strong>/cpuinfo</strong> # CPU情報</li>
<li><strong>/meminfo</strong> # メモリ情報</li>
<li><strong>/loadavg</strong> # ロードアベレージ(uptimeやtopに表示される)</li>
</ul>
</li>
<li><strong>/root/</strong> # スーパーユーザのホームディレクトリ</li>
<li><strong>/sbin/</strong> # システム管理者が使用する実行ファイル置き場</li>
<li><strong>/tmp/</strong> # 一時ファイル置き場．リブートすると消える</li>
<li><strong>/usr/</strong> # 複数マシンで共有可能なファイル置き場

<ul>
<li><strong>/src/</strong> # システムコマンドのソースコード</li>
<li><strong>/include/</strong> # システムのヘッダファイル</li>
<li><strong>/share/</strong> # 複数マシンで共有可能なファイル（特にドキュメント系）

<ul>
<li><strong>/man/</strong> # manページ

<ul>
<li><strong>/man*/</strong> セクションごとにディレクトリが分かれている</li>
</ul>
</li>
</ul>
</li>
<li><strong>/info/</strong> # infoファイル</li>
<li><strong>/local/</strong> # システムの管理者が管理するファイル</li>
</ul>
</li>
<li><strong>/var/</strong> # 頻繁に書き換えられるファイル置き場

<ul>
<li><strong>/log/</strong> # ログファイル</li>
<li><strong>/spool/</strong> # 一時的に保存するファイル</li>
<li><strong>/tmp/</strong> # /tmpと似ているが，リブートしても消えない</li>
<li><strong>/run/</strong> # 起動中のプロセスのPIDが保存される．Ubuntu12.04ではルートディレクトリの/runにシンボリックリンクが貼られている</li>
</ul>
</li>
</ul>


<h4>環境</h4>

<p>なるべく一般的なLinuxの情報を参考にしつつ，手元のUbuntu12.04と照らし合わせながら作成している．環境によっては違う部分があると思うので注意．</p>

<h4>参考</h4>

<ul>
<li><a href="http://www.atmarkit.co.jp/ait/articles/0108/07/news002.html">Windowsユーザーに教えるLinuxの常識（2）：各ディレクトリの役割を知ろう（ルートディレクトリ編） (1/2) - ＠IT</a></li>
<li><p><a href="http://www.usupi.org/sysad/239.html">ハードウェアの情報を収集する - いますぐ実践! Linuxシステム管理 / Vol.239</a></p></li>
<li><p>「<a href="http://www.amazon.co.jp/gp/product/4839938717/ref=as_li_ss_tl?ie=UTF8&camp=247&creative=7399&creativeASIN=4839938717&linkCode=as2&tag=yagays-22">Linuxの教科書　改訂版 （マイコミムック） (MYCOMムック)</a><img src="http://www.assoc-amazon.jp/e/ir?t=yagays-22&l=as2&o=9&a=4839938717" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />」では，ルートディレクトリ構成および中身のファイルに至るまで，基礎の部分について網羅的に書かれている．また，/etcと/varの概要をRed Had系とDebian系でそれぞれリストアップしている．</p></li>
<li><p>「<a href="http://www.amazon.co.jp/gp/product/4797328355/ref=as_li_ss_tl?ie=UTF8&camp=247&creative=7399&creativeASIN=4797328355&linkCode=as2&tag=yagays-22">ふつうのLinuxプログラミング Linuxの仕組みから学べるgccプログラミングの王道</a><img src="http://www.assoc-amazon.jp/e/ir?t=yagays-22&l=as2&o=9&a=4797328355" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />」では，ルートディレクトリの基本的な構造とその役割について書かれている．特に/usrと/varを使い分ける基準が解説されている点は参考になった．</p></li>
<li><p>「<a href="http://www.amazon.co.jp/gp/product/4774151432/ref=as_li_ss_tl?ie=UTF8&camp=247&creative=7399&creativeASIN=4774151432&linkCode=as2&tag=yagays-22">プロのための Linuxシステム・10年効く技術 (Software Design plus)</a><img src="http://www.assoc-amazon.jp/e/ir?t=yagays-22&l=as2&o=9&a=4774151432" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />
」では，/dev/nullおよび/dev/zeroの使い方について参考にした．他にもプロセスまわりやメモリ管理について詳細に書かれている．</p></li>
</ul>


<iframe src="http://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=yagays-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=4839938717" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>


<iframe src="http://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=yagays-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=4797328355" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>


<iframe src="http://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=yagays-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=4774151432" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[「ヒックとドラゴン」における耳を使った感情表現]]></title>
    <link href="http://yagays.github.io/blog/2013/05/05/toothless-ears/"/>
    <updated>2013-05-05T23:35:00+09:00</updated>
    <id>http://yagays.github.io/blog/2013/05/05/toothless-ears</id>
    <content type="html"><![CDATA[<p>この「ヒックとドラゴン」を観たあとの多幸感たるや，人に話さずにはいられなかったほどだ．ひとしきり知り合いに薦めまくった後，その興奮冷めやらぬままにiTunesでサウンドトラックを購入し，Amazonで「<a href="http://www.amazon.co.jp/gp/product/1557048630/ref=as_li_ss_tl?ie=UTF8&camp=247&creative=7399&creativeASIN=1557048630&linkCode=as2&tag=yagays-22">The Art of How to Train Your Dragon</a><img src="http://www.assoc-amazon.jp/e/ir?t=yagays-22&l=as2&o=9&a=1557048630" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />」をポチってしまった．</p>

<p>「ヒックとドラゴン」（原題:&#8221;How to Train Your Dragon&#8221;）は2010年に公開されたドリームワークス製作の3Dアニメーションだ．ストーリーや見どころなどの解説はWikipediaやAmazonを観ていただくとしてココでは割愛するが，個人的に感動した点を1つだけ書いておきたい．それはブルーレイの特典映像で語られているドラゴンのキャラデザインについてだ．主人公との友情を深めていく「トゥース（英語ではToothless）」と呼ばれるドラゴンは，他に登場するオリジナリティあふれるドラゴンとは違い，人間との交流で生ずる感情の機微を表現する必要があった．動きは哺乳類であるネコをモチーフにしていたり，肌は無機質な爬虫類の質感に加えて黒豹をイメージしたりしているのだが，表情を作る上で重要視したのがドラゴンの「耳」だという（正確には角という設定のようだが）．トゥースの頭についている耳を自在に動かし，喜びや興味を示す時には耳を立て，威嚇や不快感を示す際には耳を倒すという動作を付けることで，より感情を表現することができたのだという．それが一番如実に表れているのは，トゥースが地面に描いた絵をヒックが足で踏んだりして遊ぶシーンだ．表情が交互に示されるこの場面では，目の開き具合の他に，耳をひょこひょこさせる姿が印象的で，感情の変化がハッキリとわかるようになっている．この後に二人が初めて心を開くシーンがあるのだが，その展開を予感させるような印象深いシーンであり，耳の表現が非常に効果的に表れている．</p>

<p>これと似た手法は，日本のアニメーションで言えば「アホ毛」だろうか．元々は画一的な髪型に変化を持たせるため付け加えられたであろうアホ毛に動きを付けることで，本人の感情の変化を表現することができたという意味で，非常に似通ったところがある気がした．最近では長いアホ毛で記号を描いたり文字を書いたりという直接的な表現もあるようだが，髪の毛のかすかな動きが感じさせる効果は侮れないものがある．髪と感情が連動しているなんて&#8230;と思う部分もあるけれども，アニメーションの作り込みに様々な制限があるなかで発明された表現なのだと考えると，なかなかに興味深い．こういった現実離れした表現方法が許される部分においても，アニメーションを見る楽しさがある．</p>

<iframe src="http://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=yagays-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=B0051DPN6M" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>




<iframe src="http://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=yagays-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=B00386EZJU" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>




<iframe src="http://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=yagays-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=1557048630" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[「チェスの話――ツヴァイク短篇選」読了]]></title>
    <link href="http://yagays.github.io/blog/2013/05/04/review-zweig-chess/"/>
    <updated>2013-05-04T11:44:00+09:00</updated>
    <id>http://yagays.github.io/blog/2013/05/04/review-zweig-chess</id>
    <content type="html"><![CDATA[<iframe src="http://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=yagays-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=4622080915" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" align="right"></iframe>


<p>以前，こんな話を聞いたことがある．羽生善治という桁外れの天才がいなければ，将棋はこれほどまでに一般の人気を得られなかっただろう，と．それは将棋の対局の面白さだけではなく，ゴシップという下世話な興味もかき立てられると同時に，天才の人格であったり普段の振る舞いであったり天才である所以が人々を魅了するからだという．</p>

<p>本書「ツヴァイク短篇集」の最後に収録されている「チェスの話」は，チェスの名手2人がたまたまブエノス・アイレスへと向かう船上で出会い，対決をすることになるという物語だ．一人はチェス世界チャンピオンとして名を上げ，現在はチェスの試合で各地を行脚している男．天才と呼ぶに相応しい彼は，一方でチェス以外のことは何一つ人並みにできないような人間で，その様子は滑稽であり変人そのものだった．もう一人のチェスの名手は，たまたま世界チャンピオンが客と試合しているところに出くわした一人の紳士だった．彼は的確なアドバイスでその勝負を引き分けに持ち込むのだが，その知識と戦術に感嘆した客が世界チャンピオンとの対決を提案しても，その紳士は及び腰でその申し出を断り，どこかへ立ち去ってしまう．紳士を説得しようと追いかけた主人公は，どうしてあれほどまでに卓越したチェスの腕を磨いたか，紳士の過去についての独白を聞くことになる．</p>

<p>この短編では，チェスというゲームに魅了された人間の人生と思考という果てしない深淵が，圧倒的なディティールをもって描かれる．それは，考えるという行為そのものについて一人の人間の日常的な行為を超えて，自身との対峙，知識の欲求，自分と他者の存在，そして考えることに取り憑かれた人間の本質を私たちに提示する．チェスの名手になった紳士の独白は，ある種の心理実験の報告書のようであり，特殊な環境における人間の肉体的な活動と脳内で激しく回転する思考プロセスを追いかけることで，精神の実体たる思考の一つの側面を見事に表現している．紳士の思考は，話が進むにつれ異常さを増していく．その異常さが極限を迎えるとき，ようやく思考における真理が見えてくるようで，その境地に辿り着けない私のような平凡な人間にとっては，その事実にひどく惹きつけられるのだ．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[「死体入門」読了]]></title>
    <link href="http://yagays.github.io/blog/2013/05/03/review-dead-body/"/>
    <updated>2013-05-03T10:32:00+09:00</updated>
    <id>http://yagays.github.io/blog/2013/05/03/review-dead-body</id>
    <content type="html"><![CDATA[<iframe src="http://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=yagays-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=4840138370" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" align="right"></iframe>


<p>科学研究は得てして価値や有用性が厳しく求められるものだが，逆に必要であると分かっていながらも倫理的な制約や生理的嫌悪感によって，あまり活発に研究されない/できない分野というものも存在する．本書著者の専門である法医学は，その代表例と言っても過言ではないだろう．本書「死体入門」では，法医学という一分野を飛び越えて，生物の死体について様々な側面から分析し，死体というモノの定義や科学的な利用例などに迫る「死体の解説書」である．死体を観察することで，生物の成り立ちや医学的知見，人間の文化までもが見えてくる．</p>

<p>本書は死体にまつわる，ありとあらゆる内容を含んでいる．そのため雑多でトリビアルな話題も多いのだが，本書はおおまかに分けて4つの内容から構成されている．</p>

<ul>
<li>第2章「人が死ぬということ」

<ul>
<li>生物としての死体の誕生，腐敗の過程，白骨化に至るまでの詳細な変化</li>
</ul>
</li>
<li>第3章「ミイラに込めた願い」

<ul>
<li>世界中の様々な文化に共通するミイラの文化と製作技術</li>
</ul>
</li>
<li>第4章「死体をとりまく世界」

<ul>
<li>現代における死体の処理方法</li>
</ul>
</li>
<li>第5章「死体の利用法」

<ul>
<li>死体の科学的利用（法医学・解剖学・人類学など）</li>
</ul>
</li>
</ul>


<p>その中でも本書の一番の見どころといえば，本書をぱらぱらとめくって一番始めに目に飛び込んでくる九相詩絵巻のカラー写真だろう．14世紀の鎌倉時代に描かれたとされるこの作品は，生前の1段階と死後の9段階にわたる死体の変化を追ったものだ．おそらく複数の死体をモデルとして描かれたとされており，記録として描かれたわけでも科学的研究として描かれたわけではないにも関わらず，細部に至るまでリアルに描写されている．本書ではその九相詩絵巻の各相をもとに，死体の腐敗過程が現代医学の知見をもとに語られる．それぞれの相は，以下のような変化をたどっていく．死体となってもなお続く体内の生化学反応により様々な生体の変化が生じ，体の表面には色や模様が浮かび上がる．腐敗により生じる臭いによってハエが集まり，その他にも動物や昆虫が群がる．肉が腐り食べられて骨だけになっても，イヌやネズミなどがそれを齧り利用する．そして最後には土に還る．このような連続的な変化を切り取ったのが九相詩絵巻である．この絵を鑑賞するということは，現代においてむしろ非日常となった死体の変化を感じることができる限られた手段であり，死体への興味や知識を養う上で非常に重要な役割を果たす．</p>

<p>そういえば，前回紹介した<a href="http://yagays.github.io/blog/2013/05/01/review-complications/">「コード・ブルー―外科研修医救急コール」</a>の中でも，近年では遺族に対する配慮や検査機器の発達から，検死が行われる頻度が極端に下がってきていることが懸念されていた．検死が行われないことの一番の問題は，誤診や治療ミスが見過ごされる可能性があることだ．この本では，死因の特定と医療行為の正当性の判断は医者の育成においても重要であるとういことが語られていたが，死因が一見明らかな遺体の検死を行うことは，心情的な面のみならず実情からくる制約もあって，やはり難しいようだ．</p>

<p>私としては正直に言って，本書でいくら死体に関する知識を深め重要性を理解したとしても，人間の死体を目の前にしたときに感じる感情や倫理的な懸念は薄れないだろう．ただし，感情はコントロールできなくても理論的な判断になら，本書の情報は非常に有用になるはずだ．死体に関する感情的な側面と理論的な側面を区別しさえすれば，どのような人にとっても本書を大いに楽しむことができると思う．感情に隠れているだけで人間だれしも興味はあると思うので，本書の内容のどこかにはぐっと引ここまれる部分があるはずだ．</p>
]]></content>
  </entry>
  
</feed>
