<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Wolfeyes Bioinformatics beta]]></title>
  <link href="http://yagays.github.com/atom.xml" rel="self"/>
  <link href="http://yagays.github.com/"/>
  <updated>2012-06-09T01:46:26+09:00</updated>
  <id>http://yagays.github.com/</id>
  <author>
    <name><![CDATA[yag_ays]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[「エピジェネティクス 操られる遺伝子」読了]]></title>
    <link href="http://yagays.github.com/blog/2012/06/09/review-epigenetics/"/>
    <updated>2012-06-09T01:08:00+09:00</updated>
    <id>http://yagays.github.com/blog/2012/06/09/review-epigenetics</id>
    <content type="html"><![CDATA[<iframe src="http://rcm-jp.amazon.co.jp/e/cm?t=yagays-22&o=9&p=8&l=as1&asins=4478015465&ref=qf_sp_asin_til&fc1=000000&IS2=1&lt1=_blank&m=amazon&lc1=0000FF&bc1=000000&bg1=FFFFFF&f=ifr" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" align="right"></iframe>


<p>エピジェネティクスに関する一般向け書籍．ゲノミクスの次の潮流として期待されているエピジェネティクスに関して，豊富な具体例を用いて非常にわかりやすく書かれている．まず初めに母親の栄養不足が子供の肥満に影響しているということが述べられ，そこから遺伝子に依らない遺伝的影響であるエピジェネティクスの話に発展する．その後は，ヒトの遺伝疾患やモルモットの毛色の違いといった表現型などの具体例から，エピジェネティックな要因が遺伝子のどの部分にどのような形で影響してくるのかが述べられ，話はゲノムインプリンティングや幹細胞などのホットな話題にまで広がる．どれもトップダウンな解説ですんなり理解できるように組まれており，個々の話題には深入りしないものの，それぞれの話題のつながりは明確できちんと順序立てて説明されている．
個人的にはエピジェネティクス自身の歴史に関して「前成説」と「後成説」の対立を絡めて纏められていた部分で，以下の文章が非常に印象に残った．</p>

<blockquote><p>細胞を構成する他の要素と同じく，遺伝子もハードウェアの一つであり，指示を出しつつ指示を受け，監督しながら監督され，原因であると同時に結果でもあるのだ． (P.160)</p></blockquote>

<p>遺伝子は意志をもって細胞を支配しているわけではなく，あくまで細胞の一部として機能するものだ，という著者の主張が表れていて非常に良かった．</p>

<p>ちなみに，ハードカバーで250ページくらいあるがそのうち50ページくらいは訳注と参考文献なので，見た目ほど分量は無く気軽に読める．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[fastaからfastbに変換する]]></title>
    <link href="http://yagays.github.com/blog/2012/06/08/fastb/"/>
    <updated>2012-06-08T19:12:00+09:00</updated>
    <id>http://yagays.github.com/blog/2012/06/08/fastb</id>
    <content type="html"><![CDATA[<p>fastaやfastqは馴染みがあっても，fastbというフォーマットは知らない人が多いと思う．これははfastaファイルをバイナリ形式に変換したフォーマットのことで，SAMとBAMの関係と同じようなものである．</p>

<p>ALLPATHS-LGにおいて，アセンブリの評価のためにリファレンスゲノムを入力として与える際には，REFERENCE_DIRにgenome.fastaとgenome.fastbという2つのファイルが必要になる．genome.fastaに関しては，データベースなり自前で用意した配列を使えばいいのだが，genome.fastbに関しては手作業で変換をしなければならない．ということで，今回はfastaとfastbの変換の方法について，メモ程度ではあるが書いてみることにする．</p>

<!-- more -->


<h2>fastaからfastbへの変換</h2>

<p>fastaとfastbの変換には，ALLPATHS-LGをインストールした時に付属してくるFasta2Fastbを使う．使い方は簡単で，以下のように，IN=にfastaファイル名を，OUT=にfastbファイル名を指定すればよい．OUTのオプションは必須ではなく，同じファイル名のfastbファイルが生成される．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Fasta2Fastb IN=genome.fasta OUT=genome.fastb</span></code></pre></td></tr></table></div></figure>


<p>このコマンドで生成されるファイルは2つあり，</p>

<ul>
<li>genome.fastb</li>
<li>genome.fastb.names</li>
</ul>


<p>が作られる．</p>

<p>genome.fastb.namesファイルの中にはfastaファイルの中に書かれていた各配列の名前(<code>&gt;</code>で始まる行)が書かれているが，このファイルはALLPATHS-LGでは使用せず，特に意味は無さそう．</p>

<h2>fastbからfastaへの変換</h2>

<p>逆にfastbからfastaに戻す場合には，Fastb2Fastaというコマンドがある．使い方はFasta2Fastbと同様である．</p>

<h2>fastbフォーマットの圧縮効率</h2>

<p>試しにシミュレーションとして，1本の配列の長さが1Mbのfastaファイルを作成して，fastbフォーマットに変換してファイルサイズを比較してみた．結果は</p>

<ul>
<li>1Mb ： 993K -> 245K</li>
</ul>


<p>となり，<strong>約25%</strong>と四分の一ほどのサイズになった．他にも，配列の本数などを変えて幾つか実験してみたが大体同じ圧縮率になった．</p>

<h2>他にも…</h2>

<p>ALLPATHS-LGに付属しているFastb関連コマンドには，変換コマンド以外にもFastbMergeやFastbQualbToFastq，FastbQualbTrimReverse，FastbStatsなどが用意されている．どのコマンドも<code>--help</code>を付けることで使い方が表示されるので，使う時には参考になる．</p>

<p>普段から圧縮が必要になるほど大規模なfastaファイルを扱うことはそうそうないとは思うが，こういう形式のファイルがあるということを覚えておいて損はないと思う．</p>

<h3>参考</h3>

<p><a href="http://www.broadinstitute.org/crd/wiki/index.php/Fastb">http://www.broadinstitute.org/crd/wiki/index.php/Fastb</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VelvetKを使ってVelvetを用いたアセンブルに最適なk-merサイズを推定する]]></title>
    <link href="http://yagays.github.com/blog/2012/06/06/velvetk/"/>
    <updated>2012-06-06T17:12:00+09:00</updated>
    <id>http://yagays.github.com/blog/2012/06/06/velvetk</id>
    <content type="html"><![CDATA[<p>VelvetKというスクリプトが公開されたらしい．これはVelvetのアセンブルの際にユーザが指定する必要のあるk-merのkの値を，ゲノムサイズとショートリードのサイズから自動推定するスクリプトのようだ．普通ならばkの値を細かく変えてVelvetを大量に走らせてアセンブル結果を評価するというのが定石だと思うが，もしkの値が自動推定できるなら，そのkの値付近だけを重点的に調べるといったことが出来るので大幅に労力を削減できる．私自身あまりVelvet/Oasesを使った経験が無いのだが，取り敢えず一通り使ってみた．</p>

<!-- more -->


<h2>インストール</h2>

<p>インストールは簡単で，Perlスクリプトを落としてくるだけで実行出来る．外部ライブラリの依存が無いのでお手軽．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ wget http://bioinformatics.net.au/velvetk.pl </span></code></pre></td></tr></table></div></figure>


<h2>使い方</h2>

<p>VelvetKでkの推定値を算出するには，</p>

<ul>
<li><strong>ゲノム配列</strong> または <strong>ゲノムサイズ</strong></li>
<li><strong>アセンブルの元になるショートリード</strong></li>
</ul>


<p>の2つの入力が必要になる．ゲノム配列が既知の場合には<code>--genome</code>オプションを使って，fasta形式のゲノム配列のファイルを指定する．ショートリードはfastq形式などのファイルを指定することになるが，gzやbz2などの圧縮形式にも対応している．ゲノム配列を指定してVelvetKを実行するには，以下のようにコマンドを実行する．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ perl velvetk.pl --genome chr.fasta R1.fastq R2.fastq</span></code></pre></td></tr></table></div></figure>


<p>一方でde novoのようなゲノム配列が無い場合には，対象種のおおまかなゲノムサイズを入力することになる．ゲノムサイズの指定の場合には，k/M/Gといった接頭辞を使う事ができる．ゲノムサイズを数値で指定してVelvetKを実行するには，以下のようにコマンドを実行する．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ perl velvetk.pl --size=1M chr.fasta R1.fastq R2.fastq</span></code></pre></td></tr></table></div></figure>


<p>とする．</p>

<h2>擬似データで試してみる</h2>

<p>今回はお手製の擬似データで試してみることにする．</p>

<p>擬似データの作り方は簡単で，乱数を使って擬似的に作ったゲノム配列からこれまた乱数を使って擬似的にショートリードを作成するというもの．ゲノムの長さを1Mbとして，100bpのペアエンドの配列を500,000本用意して，カバレッジ100xくらいのゲノムシーケンスを想定した．</p>

<p>その擬似データセットで実行してみると以下のような出力が得られた．実際にはショートリードの長さや本数も不均一になるので，以下のように各値が綺麗な感じにはならないと思う．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ perl velvetk.pl --genome chr.fasta R1.fastq R2.fastq
</span><span class='line'>Estimating target genome size from 'chr.fasta'
</span><span class='line'>Target genome size is 1000000 bp
</span><span class='line'>Desire k-mer coverage of 25
</span><span class='line'>Using cat for R1.fastq
</span><span class='line'>Read 500000 sequences from R1.fastq
</span><span class='line'>Using cat for R2.fastq
</span><span class='line'>Read 500000 sequences from R2.fastq
</span><span class='line'>Considered 1000000 reads with lengths 100..100 bp
</span><span class='line'>K       #Kmers  Kmer-Cov
</span><span class='line'>1       100000000       100.0
</span><span class='line'>3       98000000        98.0
</span><span class='line'>5       96000000        96.0
</span><span class='line'>7       94000000        94.0
</span><span class='line'>9       92000000        92.0
</span><span class='line'>〜〜〜中略〜〜〜
</span><span class='line'>71      30000000        30.0
</span><span class='line'>73      28000000        28.0
</span><span class='line'>75      26000000        26.0
</span><span class='line'>77      24000000        24.0
</span><span class='line'>79      22000000        22.0
</span><span class='line'>81      20000000        20.0
</span><span class='line'>83      18000000        18.0
</span><span class='line'>85      16000000        16.0
</span><span class='line'>87      14000000        14.0
</span><span class='line'>89      12000000        12.0
</span><span class='line'>91      10000000        10.0
</span><span class='line'>93      8000000 8.0
</span><span class='line'>95      6000000 6.0
</span><span class='line'>97      4000000 4.0
</span><span class='line'>99      2000000 2.0</span></code></pre></td></tr></table></div></figure>


<p>入力ファイルをそれぞれ読み込んだ後，それぞれのkの値に対して#kmersとKmer-Covが表示される．#kmersはショートリードのデータからカウントできるk-merの本数で，例えばK=99の場合では100bpから抜き出せる99merは2つあるので，今回の場合リード数500,000*2の合計2,000,000という感じだろう．次のKmer-Covは，いわゆるK-mer Coverageと呼ばれるもので，実際のカバレッジとk-merで見た時のカバレッジの割合，もしくは変換するときの係数に当たる．</p>

<p>ではどうやってこのリストからVelvetに最適なkの値を推定するかというと，出力の始めの方に書かれている</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Desire k-mer coverage of 25</span></code></pre></td></tr></table></div></figure>


<p>のところを見て，Kmer-Covが25を下回った時のkの値が最適なkの値とする．今回の場合だとk=77でKmer-Covが24.0になるので，k=77が最適なk-merのサイズとなる．</p>

<p>それではなぜ25なのかというと，このスクリプトの場合だとデフォルトだからということになってしまうのだが，どうやらk-mer Coverageにはだいたい10~20あれば十分という知見(多分経験則)があるらしい．一般的にはkの値が小さいとコンティグが繋がりにくく，kの値が大きいと細かな違いをコンティグに反映出来無いといったsensitivityとspecificityのトレードオフがある．それらのいい具合の中間点ということで，k-mer Coverageを見て判断しようということらしい．</p>

<p>また，このスクリプトでは閾値となるk-mer Coverageを変更するオプション<code>--cov</code>や，リストの出力を抜きにして最適なKの値だけを出力するオプション<code>--best</code>なども用意されている．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ perl velvetk.pl --best --cov=20 --size=1M R1.fastq R2.fastq
</span><span class='line'>Target genome size is 1000000 bp
</span><span class='line'>Desire k-mer coverage of 20
</span><span class='line'>Using cat for R1.fastq
</span><span class='line'>Read 500000 sequences from R1.fastq
</span><span class='line'>Using cat for R2.fastq
</span><span class='line'>Read 500000 sequences from R2.fastq
</span><span class='line'>Considered 1000000 reads with lengths 100..100 bp
</span><span class='line'>81
</span></code></pre></td></tr></table></div></figure>


<p> 上の場合では，k=81が最適とおもわれるkの推定結果となる．</p>

<h2>実はWeb版もある</h2>

<p>ちなみに，ここまで書いておいて難だが，実はVelvetKと同作者が作った簡易版「Velvet Advisor」がWebアプリケーションとして既に存在している．ただ，この簡易版は複数の入力ファイルに対応していないので，使えるケースが制限されている．普通は複数のライブラリを読んでアセンブルするとと思うので，まあ今回のVelvetKで使いやすくなったという感じだろうか．</p>

<p><a href="http://dna.med.monash.edu.au/~torsten/velvet_advisor/">http://dna.med.monash.edu.au/~torsten/velvet_advisor/</a></p>

<h2>まとめ</h2>

<p>今回は擬似データを使ってVelvetKを動かしてみたが，これからアセンブルをするという人にとってはパラメータの大雑把な目安となって良いと思う．どれだけの精度で当たるのか不安なところもあるので，実際にVelvetを使ったアセンブルのプロジェクトでVelvetKの推定値がどれだけ当たっているかが知りたいところだけれども，結局目安としてしか使わないのだから，まあ適当でいいんだろう．</p>

<h2>参考資料</h2>

<ul>
<li><a href="http://bioinformatics.net.au/software.velvetk.shtml">http://bioinformatics.net.au/software.velvetk.shtml</a></li>
<li><a href="http://kevin-gattaca.blogspot.jp/2012/06/fwd-velvet-users-velvetkpl-choose-good.html">http://kevin-gattaca.blogspot.jp/2012/06/fwd-velvet-users-velvetkpl-choose-good.html</a></li>
<li><a href="http://dna.med.monash.edu.au/~torsten/velvet_advisor/">http://dna.med.monash.edu.au/~torsten/velvet_advisor/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[「せめぎ合う遺伝子」読書ノート 2章その1]]></title>
    <link href="http://yagays.github.com/blog/2012/06/05/genesinconflict-2-1/"/>
    <updated>2012-06-05T17:28:00+09:00</updated>
    <id>http://yagays.github.com/blog/2012/06/05/genesinconflict-2-1</id>
    <content type="html"><![CDATA[<iframe src="http://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=yagays-22&o=9&p=8&l=as1&m=amazon&f=ifr&ref=qf_sp_asin_til&asins=432005699X" style="width:120px;\
height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" align="right"></iframe>


<h2>2章 常染色体キラー</h2>

<p>2章の最初に紹介される利己的な遺伝因子は，ハツカネズミのtハプロタイプである．利己的な遺伝因子の中では発見が早く(1927年)，研究から得られた知見も多い．</p>

<ul>
<li><strong>その因子は，どのようにして利己的な優位性を獲得したのだろうか？</strong>

<ul>
<li>ヘテロ接合体オスにおいて，野生型の精子を無力化させる</li>
</ul>
</li>
<li><strong>いかにして，その因子は出現したのだろう？</strong>

<ul>
<li>セントロメア近辺の逆位のすぐそばに生じた分離歪曲対立遺伝子(キラー因子)</li>
<li>逆位による組み換えの妨害により，分離歪曲対立遺伝子と応答-不感性対立遺伝子の連鎖を強め安定化させる</li>
</ul>
</li>
<li><strong>どれくらい昔に出現したのだろう？</strong>

<ul>
<li>約0.3Myr前</li>
</ul>
</li>
<li><strong>大型生物に対する影響はどのようなものだろうか？</strong>

<ul>
<li>+/tハツカネズミの成獣期におけるメスの体の不均整やオスの攻撃性の違い (これらは直接的に利己的な遺伝因子が関わっているわけではない)</li>
</ul>
</li>
<li><strong>どのくらいの速度で，その因子は分布を拡大すると期待されるだろうか？</strong>

<ul>
<li>???</li>
</ul>
</li>
<li><strong>種内における頻度はどれくらいか？</strong>

<ul>
<li>5% (集団により異なる)</li>
</ul>
</li>
<li><strong>頻度を決定づけているものは何か？</strong>

<ul>
<li>ホモ接合体およびヘテロ接合体の適応度</li>
<li>集団サイズと相関</li>
</ul>
</li>
<li><strong>いくつかの種にその因子が見いだされるのに，他の種には見いだされないのはなぜか？</strong>

<ul>
<li><em>Mus musculus</em>亜種の種分化後に種間交雑で広まったから</li>
</ul>
</li>
<li><strong>ゲノムの他の因子は，利己的な因子に対抗してどのような適応を強いられてきたか？</strong>

<ul>
<li>抑制因子の出現などによるゲノム内コンフリクト</li>
</ul>
</li>
<li><strong>ホストの系統に対しておよぼしてきた効果以外に，どのような影響をもたらすだろうか？</strong>

<ul>
<li>???</li>
</ul>
</li>
</ul>


<p>1章で述べられた利己的因子の基礎に関する問題に，tハプロタイプのケースで解答を作成してみた．個別のケースでは答えにくい問題もあるが，本文の纏めとして特徴が俯瞰できるように，ある程度問題を曲解したり無理やり当てはめた部分もある．</p>

<!-- more -->


<h3>2.1</h3>

<ul>
<li>T突然変異の発見により，tを持つかどうかが表現型から判断することができるようになった

<ul>
<li>利己的な遺伝因子は普通表現型の変化を伴わないので見つけることが難しい</li>
<li>T突然変異は尾部形成因子として，ハツカネズミの尾を短くする</li>
<li>+/tヘテロ接合のハツカネズミは尾がないという表現型を示し，その時tはドライヴする</li>
<li>T/Tおよびt/tのホモ接合の個体は死亡してしまう</li>
</ul>
</li>
</ul>


<br />


<ul>
<li>tハプロタイプは17番染色体上の1/3を占め，3つドライヴ因子と4つの逆位を持つ

<ul>
<li>ドライブ因子＝分離歪曲遺伝子</li>
<li>逆位は野生型染色体との組み換えを妨げる</li>
<li>組み換えが起こらず連鎖を繰り返すことにより利己的な性質を保ったままその遺伝因子は頻度を高める</li>
<li>組み換えが起こりにくい状態でtの領域が大きくなることにより，多くの遺伝子が突然変異を蓄積する</li>
</ul>
</li>
</ul>


<br />


<ul>
<li>tコンプレックスは0.1Myr前頃から存在し，既に種分化していた<em>Mus musculus</em>の4亜種に広まった

<ul>
<li>tコンプレックスの中の逆位のうち最も古いとされるものは3Myr前に生じたとされる</li>
<li>Mus musculusの亜種は0.5~1.0Myr前に分岐したと考えられている</li>
</ul>
</li>
</ul>


<br />


<ul>
<li>tコンプレックスに含まれる応答-不感性対立遺伝子<em>Tcr</em>によりドライヴ因子の持つ分離歪曲効果から保護する

<ul>
<li>ドライヴ因子は他の精子を殺戮するが，<em>Tcr</em>を持っている場合は生き残ることができる</li>
<li><em>Tcr</em>は1倍体特異的に発現する(精子形成後期に発現)</li>
<li>単純なメカニズムとして，ドライヴ因子が毒素を出して<em>Tcr</em>が解毒剤を出すということが考えられるが，これは他のドライヴ因子の性質によって否定されている</li>
<li>ドライヴ因子による精子の機能不全の原理は幾つか考えられる

<ul>
<li>精子の運動上の欠陥</li>
<li>先体反応の不全</li>
<li>精子形成中の妨害</li>
</ul>
</li>
</ul>
</li>
</ul>


<br />


<ul>
<li>精子の配偶子競争の重要性は種の生殖様式に依る

<ul>
<li>一夫一婦制の場合は純粋にキラー因子を持つ精子が受精する (繁殖力は低下しない)</li>
<li>メスが複数のオスと交配する(多夫多妻制?)場合には，キラー因子を持つ精子と野生型の精子との競争になる

<ul>
<li>野生型の個体の精子は，キラー因子を持つ個体が野生型の精子を殺すことによりいくぶん有利になる</li>
</ul>
</li>
</ul>
</li>
</ul>


<br />


<ul>
<li>キラー因子と抵抗性対立遺伝子の存在頻度はホストにかける負担のド愛で決まる

<ul>
<li>tハプロタイプの場合，t/tオスの不妊という形でホストに負担をかける</li>
<li>キラー因子が存在頻度を高め長期的に安定するには，抵抗性対立遺伝子の抵抗のコストが高いことが重要である (または負担をかけない抵抗性対立遺伝子が存在しないこと)</li>
</ul>
</li>
</ul>


<br />


<ul>
<li>逆位は組み換えを抑制し，キラー因子と抵抗性因子の連鎖を強め，分布拡大を図る

<ul>
<li>逆位の組み替え抑制はドライヴ性とは無関係な多数の遺伝子を結びつけ，劣勢致死因子を保有することになる</li>
<li>自然選択の有効性が低くなり劣化する(有害な突然変異の蓄積であったり，適応性の低下など)</li>
<li>tコンプレックスは大半が致死性死因子を持つ</li>
<li>致死因子は群選択や血縁選択の効果に乗じて維持されてきた可能性がある</li>
<li>致死遺伝子の活動する時期も胚期のなかで異なり，母親の生殖に影響してくる</li>
<li>結論としては，致死因子が積極的に維持されているかどうかは不明</li>
</ul>
</li>
</ul>


<br />


<ul>
<li>殺戮強度を巡るゲノム内コンフリクトがあると考えられている

<ul>
<li>キラー染色体上のアレルは殺戮を促進する方に，一方では野生型の染色体上のアレルは殺戮を抑制する方に働く

<ul>
<li>キラー染色体上のアレルはキラー因子との連鎖を強め，キラー複合体は進化の過程で染色体上に広がっていくと考えられる</li>
<li>野生型の染色体上のアレルは他の染色体上にも抑制因子が生じ，ドライブを低下させてきた</li>
</ul>
</li>
</ul>
</li>
</ul>


<br />


<ul>
<li>tコンプレックス末端の逆位内に主要組織適合遺伝子複合体MHCがある

<ul>
<li>免疫反応，配偶者選択，血縁認識，自己認識に関わる</li>
<li>これらの遺伝子は著しく多型的な性質を持ち，野生型では基本的にヘテロ接合的である</li>
<li>tハプロタイプは，MHCの多様性を減少させ，t特有の限られたMHCハプロタイプを持つ</li>
</ul>
</li>
</ul>


<br /> 


<ul>
<li>tハプロタイプのドライヴは雌雄で適応度に違いが生じたとしても，全体的な利益が上回れば維持される

<ul>
<li>性によって偏ったドライヴによって，新しく性拮抗性遺伝子が生じる</li>
<li>tハプロタイプの有無により発生初期において性の偏りがあるわけではなく，成獣期において適応度(表現型)の違いを生じる

<ul>
<li>+/tメスは+/+メスよりも低い適応度を示す(体の非対称性，不均整)</li>
<li>+/tオスは+/+オスよりも高い適応度を示す</li>
</ul>
</li>
</ul>
</li>
<li>tが集団内で頻度を高めるために重要な要素はt/tメスの繁殖成功率である

<ul>
<li>t/tメスの繁殖成功率が低ければt/tの組み換えは起こりにくい</li>
</ul>
</li>
</ul>


<br />


<ul>
<li>tの頻度は集団によりばらつきがあり平均して5%程度だった

<ul>
<li>自然集団を対象にsた調査から，分布頻度は0~71%にわたった</li>
<li>tの平衡頻度に影響するパラメータは幾つか考えられる

<ul>
<li>ドライヴの程度 (0.9程度)</li>
<li>tコンプレックスのホモ接合型の適応度効果 (t/tオスは不妊，t/tメスは適応度が低い)</li>
<li>tコンプレックスのヘテロ接合型の適応度効果 (+/tにおいても適応度の低下がある)</li>
<li>近交の程度 (近交=ヘテロ接合の頻度低下．tはヘテロ接合にのみドライヴを発揮する)</li>
</ul>
</li>
</ul>
</li>
<li>集団の大きさとtの頻度には相関がある (集団が大きいとtの頻度が低くなる)</li>
</ul>


<h3>参考資料</h3>

<ul>
<li><a href="http://d.hatena.ne.jp/shorebird/20060426">http://d.hatena.ne.jp/shorebird/20060426</a></li>
<li><a href="http://d.hatena.ne.jp/shorebird/20060501">http://d.hatena.ne.jp/shorebird/20060501</a></li>
<li><a href="http://d.hatena.ne.jp/shorebird/20060502">http://d.hatena.ne.jp/shorebird/20060502</a></li>
<li><a href="http://www.brc.riken.go.jp/lab/mcd/mcd2/cn7/pg64.html">http://www.brc.riken.go.jp/lab/mcd/mcd2/cn7/pg64.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ALLPATHS-LGを最小構成で実行する]]></title>
    <link href="http://yagays.github.com/blog/2012/06/04/allpaths-lg-introduction/"/>
    <updated>2012-06-04T13:08:00+09:00</updated>
    <id>http://yagays.github.com/blog/2012/06/04/allpaths-lg-introduction</id>
    <content type="html"><![CDATA[<p><a href="http://yagays.github.com/blog/2012/06/02/allpaths-lg-dataset/">前回</a>は，ALLPATHS-LGの入力データの制約についてFragment LibraryとJumping Libraryの2つが最低でも必要ということを書いたが，今回は実際にALLPATHS-LGを動かすところを見ていく．ただし，複雑で込み入った細かい部分は分からないので，最小構成でとにかくアセンブル結果を得るということだけを解説していこうと思う．</p>

<!-- more -->


<p>今回はALLPATHS-LGのexampleを使って解説していく．このexampleにはprepare.shとassemble.shという2つのシェル・スクリプトが付属しており，これらを動かせばアセンブルは実行できるのだが，今回は最小構成で実行するということで，これらの用意されたスクリプトを使わず直にコマンドを叩いて動かしていこうと思う．ALLPATHS-LGパイプラインの特徴である美しいディレクトリ構成などは一切無視して進むので，もし上手に実験を組んでディレクトリ構成を管理したい場合はマニュアルを熟読していただきたい．</p>

<h3>概要</h3>

<p>まず，ALLPATHS-LGを動かすために必要なステップが3つある．</p>

<ol>
<li><strong>in_groups.csvとin_libs.csvを作る</strong></li>
<li><strong>PrepareAllPathsInputs.plを実行する</strong></li>
<li><strong>RunAllPathsLGを実行する</strong></li>
</ol>


<p>最低限この3つを実行すれば，アセンブル結果が出てくる．では個別に見てこう．</p>

<h3>in_groups.csvとin_libs.csvを作る</h3>

<p>ALLPATHS-LGでは，入力となるNGSデータの情報をin_groups.csvとin_libs.csvの2つに記述する必要がある．</p>

<p>in_groups.csvでは，アセンブルの元データとなるNGS入力データの場所と種類，そしてライブラリの名前をコンマ区切りのテキストとして保存する．exampleのin_groups.csvは以下のようになっている．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cat in_groups.csv
</span><span class='line'>        file_name, library_name, group_name
</span><span class='line'>seq/frags.?.fastq, Solexa-25396,      frags
</span><span class='line'>seq/jumps.?.fastq, Solexa-11542,      jumps</span></code></pre></td></tr></table></div></figure>


<p>file_nameは入力データのパスを指定する．相対パスでも絶対パスでも問題ない．入力ファイルがペアエンドなどで対になっている場合は<strong><code>?</code></strong>や<strong><code>*</code></strong>のワイルドカードを使う必要があり，例えばR1.fastqとR2.fastqなら&#8221;R?.fastq&#8221;とすれば2つのファイルをひとまとまりとして認識できる．次にlibrary_nameとgroup_nameだが，これらは入力データを区別するためにユーザが指定する項目で，自由に名前を付けることができる．library_nameは後述のin_libs.csvでも共通して使われるので，そちらの配列情報の項目と名前を合わせる必要がある．また，group_nameはそれぞれの配列データにユニークな名前を付ける必要がある．上の例ではfragsとjumpsとなっているが，これはライブラリの種類を指定しているわけではなく，ただ名前を付けているだけなので勘違いしないように注意が必要である．</p>

<p>次に，in_libs.csvでは，アセンブルの元データとなるNGS入力データのライブラリの種類とインサートサイズなどの各情報をコンマ区切りのテキストとして保存する．exampleのin_libs.csvは以下のようになっている．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cat in_libs.csv
</span><span class='line'>library_name, project_name, organism_name,     type, paired, frag_size, frag_stddev, insert_size, insert_stddev, read_orientation, genomic_start, genomic_end
</span><span class='line'>Solexa-25396,         test,   test.genome, fragment,      1,       180,          10,            ,              ,           inward,             0,           0
</span><span class='line'>Solexa-11542,         test,   test.genome,  jumping,      1,          ,            ,        3000,           500,          outward,             0,           0</span></code></pre></td></tr></table></div></figure>


<p>まず一番左のカラムには，先ほどのin_groups.csvで指定したlibrary_nameと同じものを入力する．そして，それ以降の行で詳しいライブラリの情報を指定していく．project_nameやorganism_nameなどはユーザが自由に名前を付ける事ができる．それ以降のtypeやpaired，frag_sizeなどではライブラリの情報を入力していくが，関係ない項目は空白にしておいて良い．このあたりの入力情報の詳細はマニュアルに詳しく記載されているので，そちらを参照されたい．</p>

<p>さて，in_groups.csvとin_libs.csvが揃ったところで，次からいよいよALLPATHS-LGを動かしていく．</p>

<h3>PrepareAllPathsInputs.plを実行する</h3>

<p>さて，ここから実際にALLPATHS-LGを動かしていくわけだが，まずはPrepareAllPathsInputs.plというスクリプトを動かして，パイプラインのディレクトリ作成や入力データの変換などを行う．</p>

<p>それでは実際にPrepareAllPathsInputs.plを動かしてみよう．先ほどのin_groups.csvとin_libs.csvがあるディレクトリで，以下のコマンドを実行する．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>PrepareAllPathsInputs.pl DATA_DIR=$PWD PLOIDY=2  </span></code></pre></td></tr></table></div></figure>


<p>最低限必要なのはDATA_DIRとPLOIDYの2つだけである．DATA_DIRはアセンブル結果を保存するディレクトリを指定するオプションで，今回は最小構成ということで，このスクリプトを動かしたディレクトリ以下に結果を置くようにする．PLOIDYではゲノムアセンブリの対象種における倍数を指定する．1倍体なら1，2倍体なら2という具合だが，現在のところALLPATHS-LGは2倍体以上の倍数体には対応していないようだ．なお，マニュアルには他にもオプションが指定されているが，PICARD_TOOLS_DIRは入力ファイルがbamファイルでなければ必要ない．</p>

<h3>RunAllPathsLGを実行する</h3>

<p>入念な下準備が終わったところで，いよいよALLPATHS-LGの本体を動かす．まずは実行コマンドを見てみよう．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>RunAllPathsLG PRE=. REFERENCE_NAME=. DATA_SUBDIR=. RUN=allpaths SUBDIR=run  </span></code></pre></td></tr></table></div></figure>


<p>色々とオプションが指定されているが，これらは全てディレクトリに関するものである．PREやREFERENCE_NAME，DATA_SUBDIRで指定されているドットは「現在のディレクトリ」を表している．RUNやSUBDIRは出力結果のが置かれるディレクトリの名前になり，上のコマンドの場合には，final.assembly.fastaなどのアセンブル結果はallpaths/ASSEMBLIES/runのディレクトリ以下に置かれることになる．マニュアルではTARGETSというオプションがあるが，これは既にゲノムが読まれていたりする場合に，それをリファレンスとして使うことでALLPATHS-LGのアセンブル結果と比較してまとめて評価してくれるというものである．今回は使用していないので関係無いが，exampleではリファレンスゲノムもきちんと用意されているので，試すことはできる．</p>

<h3>まとめ</h3>

<p>ということで，足早にALLPATHS-LGの使い方を最小構成で見てきた．こうやって並べてみると，実際にアセンブルに必要な項目というのは非常に少なく，in_groups.csvとin_libs.csv，そしてPLOIDYさえ指定すればアセンブルすることはできる事がわかる．まあ実際に動かすとアセンブルが上手くいかない部分は多々出てくると思うが，最小構成で一度実行できてさえいれば次からはパラメータチューニングをしていくだけなので，アセンブル結果の評価と並行して進めることができる．ALLPATHS-LGでは他にも様々な種やデータに対応できるよう色々とオプションが用意されているので，色々試してみると面白かもしれない．</p>

<h3>参考サイト</h3>

<ul>
<li><a href="http://www.broadinstitute.org/software/allpaths-lg/blog/">http://www.broadinstitute.org/software/allpaths-lg/blog/</a></li>
<li><a href="http://evomics.org/wp-content/uploads/2012/01/Allpaths_exercises.pdf">http://evomics.org/wp-content/uploads/2012/01/Allpaths_exercises.pdf</a></li>
<li><a href="http://evomics.org/learning/assembly-and-alignment/allpaths-lg/">http://evomics.org/learning/assembly-and-alignment/allpaths-lg/</a></li>
<li>(pdf) <a href="http://evomics.org/wp-content/uploads/2012/01/Allpaths_exercises.pdf">http://evomics.org/wp-content/uploads/2012/01/Allpaths_exercises.pdf</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[「せめぎ合う遺伝子」読書ノート 1章]]></title>
    <link href="http://yagays.github.com/blog/2012/06/03/genesinconflict-1/"/>
    <updated>2012-06-03T14:31:00+09:00</updated>
    <id>http://yagays.github.com/blog/2012/06/03/genesinconflict-1</id>
    <content type="html"><![CDATA[<iframe src="http://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=yagays-22&o=9&p=8&l=as1&m=amazon&f=ifr&ref=qf_sp_asin_til&asins=432005699X" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" align="right"></iframe>


<p>「せめぎ合う遺伝子」(Genes in Conflicts)を先週あたりから少しずつ読み進めている．元々の動機としては，生物学を勉強するにあたり「○○学」なんて大層な名前の分厚い「辞書」を読み進めるのに飽きたのがきっかけで，実例を学びながら時々辞書を引きつつ勉強しようと思ってこの本を選んだのが始まりだった．当初の目的通りこの本をさらっと読み進めながら辞書の方の読解を並行して進められるかと思いきや，これが思いの外キツい本で今は必死になって読み進めている．ある意味計画通りな反面，辞書が示す範疇を超えるのではないかと思うような濃厚さで，半ば辞書を放り出して本に齧り付いている感じがある．</p>

<p>そんなこんなで，無いも同然な生物学の知識を総動員して読み進めているわだが，読み進めるにあたり<a href="http://d.hatena.ne.jp/shorebird/20060424">原書を読まれた方の読書記録</a>が大いに理解の手助けになり参考にさせてもらっている．ということで，自分も実際に書きだして理解を深めようと思い，自分の理解の範囲内で纏めを作って見ることにした．間違ったことを書いていたり理解が浅い部分は多々あると思うので，そのあたり「生物学初学者が書いている」ことを念頭に置いてもらえればと思う．</p>

<h3>1章</h3>

<p>1章はガイダンス的な内容で，この本のメインテーマである利己的な遺伝因子の定義や，その戦略，研究の歴史が紹介されている．そして最後に，利己的な遺伝因子がいかに広範囲に及ぶ分野をまたぐテーマであり，本書はそれらを包括的に扱い体系化させようとしていることが述べられている．</p>

<!-- more -->


<ul>
<li>遺伝子にはせめぎ合い(コンフリクト)がある

<ul>
<li>利己的な遺伝因子と抑制因子の対立</li>
<li>利益：<strong>出現頻度</strong> (<strong>分布</strong>)</li>
</ul>
</li>
</ul>


<br />


<ul>
<li>遺伝的協調性を持たない利己的な遺伝因子

<ul>
<li>生物の適応性と密接に関連する遺伝子が，自然選択Natural Selectionの結果，自身の頻度(分布)を広げる</li>
<li>このような遺伝的協調性は遺伝子が公平に伝達されることによりもたらされる</li>
<li>このとき世代間の遺伝頻度は変化しない(いわゆるハーディー・ワインバーグの法則)</li>
<li>しかし，利己的な遺伝因子は個体の適応度に寄与しないにもかかわらず分布を広げる</li>
</ul>
</li>
</ul>


<br />


<ul>
<li>利己的な遺伝因子に関わる用語定義

<ul>
<li>ドライヴdrive

<ul>
<li>伝達率が50%を上回ること (超メンデル的Super-Mendelian)</li>
</ul>
</li>
<li>ドラッグdrug

<ul>
<li>伝達率が50%を下回ること(下メンデル的sub-Mendelian)</li>
</ul>
</li>
</ul>
</li>
</ul>


<br />


<ul>
<li>利己的な遺伝因子の代表的な3つの戦略

<ul>
<li>干渉interference</li>
<li>過複製overreplication</li>
<li>ゴノタキシスgonotaxis (生殖系列走性)</li>
<li>ーー</li>
<li>あくまでこれらの戦略は個体の適応度（ここでは「生物としての質」）を変化させない</li>
</ul>
</li>
</ul>


<br />


<ul>
<li>ゲノムの血縁コンフリクトにより利己性を発揮する場合がある

<ul>
<li>血縁関係が近いと，同じ遺伝子を持っている確率が高い</li>
<li>母親由来/父親由来 (maternal/paternal)</li>
<li>ゲノムインプリンティング</li>
</ul>
</li>
</ul>


<br />


<ul>
<li>ショウジョウバエ<em>D.melanogaster</em>で観測された<em>P</em>因子は劇的な分布拡大を見せた

<ul>
<li>系統間交雑における不妊や突然変異率の高さ，オスの組み換え発生などの異常は<em>P</em>因子によるものだった</li>
<li><em>P</em>因子は20世紀半ばに<em>D.willistoni</em>から<em>D.melanogaster</em>の遺伝子プールに持ち込まれ，世界中に広まった</li>
</ul>
</li>
</ul>


<br />


<ul>
<li>利己的な遺伝因子が必ずしも遺伝子のホストである個体の適応度に影響しないわけではない

<ul>
<li>ドライヴ性性染色体</li>
<li>雄性不稔ミトコンドリア</li>
</ul>
</li>
</ul>


<br />


<ul>
<li>利己的な遺伝因子の別称

<ul>
<li>アウトロー遺伝子 outlaw gene</li>
<li>超利己的遺伝子 ultraselfish gene</li>
<li>自己普及推進遺伝因子 self-promoting genetic element</li>
</ul>
</li>
</ul>


<br />


<ul>
<li>ドライヴの別称

<ul>
<li>伝達比の歪曲 transmission ratio distortion</li>
<li>分離の歪曲 segregation distortion</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ALLPATHS-LGで使用できるライブラリサイズの制限]]></title>
    <link href="http://yagays.github.com/blog/2012/06/02/allpaths-lg-dataset/"/>
    <updated>2012-06-02T15:52:00+09:00</updated>
    <id>http://yagays.github.com/blog/2012/06/02/allpaths-lg-dataset</id>
    <content type="html"><![CDATA[<p>ALLPATHS-LGは複数のライブラリで読まれたショートリードを組み合わせてゲノムアセンブルをするソフトウェア（パイプライン）である．比較的新しいゲノムアセンブラで性能もかなり良いらしく，<a href="http://www.broadinstitute.org/software/allpaths-lg/blog/">公式ブログ</a>のアセンブル履歴を見ると非モデル生物を中心にかなり使われている印象がある．ただ，その反面かなり癖のあるソフトウェアで，インストールが鬼門・動かすのが難しい・インターネットに資料が少ないという三重苦で，初心者にはかなりハードルの高いソフトウェアと言わざるを得ない．その中でも個人的に一番やっかいだと思うポイントはパイプライン入力に使うデータセットの準備で，折角苦労してALLPATHS-LGが使える環境を整えたとしても，使えるデータが無いとそもそも動かないということになりかねない．</p>

<p>ということで，今回はALLPATHS-LGを動かすために必要なライブラリについて見ていく．私自身も厳密に調べたわけではないので間違い等あるかもしれないが，もし詳しい方がいらっしゃればご指摘頂ければ幸い．</p>

<p> <!-- more --></p>

<p>まず，ALLPATHS-LGが想定してるNGSショートリードは，長さ~100bp程度のペアエンドである．454のロングリードなどには対応していないようだが，最近のバージョンアップでillumina+PacBioのハイブリッドアセンブルが出来るようになっているらしい（<a href="http://www.broadinstitute.org/software/allpaths-lg/blog/?p=463">url</a>）．</p>

<p>ここまでは問題無いのだが，次のペアエンドのライブラリの種類に関する条件が非常に複雑である．まずALLPATHS-LGでは，ショートリードのライブラリは以下の3つに区分される．</p>

<ul>
<li>Fragment Library (Short Library)</li>
<li>Jumping Library (long Library)</li>
<li>Long Jumping Library</li>
</ul>


<p>このうち，アセンブルに必要となるライブラリはFragment LibraryとJumping Libraryである．ここで重要なのは，<strong>どちらも必ず最低1つ</strong>は必要になるということである．たとえFragment Libraryがいくつあっても，Jumping LibraryがなければALLPATHS-LGは動かない．これが非常に重要で，後述のライブラリの条件で詳しく述べるが，Jumping LibraryのInsert sizeには制限があるため，これをクリアするデータを持っていない場合はそもそもALLPATHS-LGを動かす事ができない．</p>

<h2>Fragment Library</h2>

<p>ではそれぞれのライブラリの条件を順に見ていこう．まずFragment Libraryだが，これはインサートサイズの短い配列のことを指す．ただこれには制約があり，ペアエンドの読まれたリードが重なっている必要がある．これだけでは何のことか分からないと思うので例を使って説明すると，例えば100bpのペアエンドの場合では両端から100bpずつ読まれるので，それらが重なるようなインサートサイズを考えると，200bp以下である必要がある．もしインサートサイズが300bpの場合では両端のリードの間に隙間が出来てしまうので，このライブラリはFragment Libraryにはならない．実際にはインサートサイズは少しばらつきがあり，ALLPATHS-LGでもインサートサイズの値に加えて標準偏差stddevも指定できるようになっているが，基本的にペアエンドリードが重なるような長さのものを使う必要がある．</p>

<h2>Jumping Library</h2>

<p>次にJumping Libraryである．ALLPATHS-LGではインサートサイズが3,000bp〜10,000bp程度のライブラリを想定している．ただしこれにも制約があり，ペアエンドリード間の長さ(separation size)が最低1,000bp以上ないとJumping Libraryと見なされない．ということは，100bpのペアエンドの場合，Jumping Libraryとして認識されるには最低1,200bp程度のインサートサイズが必要となる．これが非常にややこしいところで，Fragment Libraryより長いインサートはJumping Libraryになるかというと，そうでもないのである．じゃあ100bpペアエンドリードでインサートサイズが200bp〜1000bpの間のライブラリはどれに分類されるかというと，これが非常に謎な部分で私自身もあまり良くわかっていない．これらのインサートサイズのライブラリはFragment LibraryとしてALLPATHs-LGの入力ファイルに登録することは出来る(Validationに通る)ので，使われないことは無いと思う．ただし，このFragment Libraryモドキ単体だけではFragment Libraryが不足しているとしてALLPATHS-LGを動かすことが出来無いので，最低でも200bp以下のオーバーラップしているライブラリと組み合わせて使う必要がある．謎い．</p>

<h2>Long Jumping Library</h2>

<p>最後にLong Jumping Libraryだが，マニュアルによるとインサートサイズが20kbpsのライブラリを想定しているらしい．前述のJumping Libraryにおいてペアエンドリード間の長さの上限が10kbpなので，それ以上はLong Jumping Libraryとしても良さそうである．</p>

<p><img src="http://dl.dropbox.com/u/142306/b/allpaths-lg-dataset.png" alt="Fragment LibraryとJumping Libraryの模式図" /></p>

<p>といった感じでALLPATHS-LGを動かすために必要なライブラリの種類を見てきた．結論としては兎に角動かすためのデータセットの制限がシビアということで，データのライブラリサイズなどの情報をきちんと把握しておく必要がある．まあデータが揃っていたとしてもALLPATHS-LGを動かすのも一苦労なのだが，この話はまた別の機会に書ければ書くことにする．というか自分も理解していないところが多いので手探り感が強いが&#8230;．</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[github pages + Octopressでブログを作ってみた]]></title>
    <link href="http://yagays.github.com/blog/2012/05/23/new-post/"/>
    <updated>2012-05-23T15:52:00+09:00</updated>
    <id>http://yagays.github.com/blog/2012/05/23/new-post</id>
    <content type="html"><![CDATA[<p>お久しぶりです，yag_aysです．</p>

<p>さくらVPSの解約に伴い，Wordpressで立てていたblogをGithub Pagesで立て直すことにしました．</p>

<p>ということで，また懲りずに技術系記事をひっそりと書いていく予定です．よろしくお願いします．</p>

<h2>以下メモ</h2>

<ul>
<li>Githubのレポジトリを作成する</li>
</ul>


<p><img src="http://dl.dropbox.com/u/142306/b/github_accountsetting.png" alt="アカウント登録" /></p>

<ul>
<li>ページを作成してindex.htmlを作成すると，以下のようにNotificationが来る．</li>
</ul>


<p><img src="http://dl.dropbox.com/u/142306/b/github_notify.png" alt="Notification" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> git clone git://github.com/imathis/octopress.git octopress
</span><span class='line'> cd octopress
</span><span class='line'> gem install bundler
</span><span class='line'> bundle install
</span><span class='line'>
</span><span class='line'> rake setup_github_pages
</span><span class='line'> rake generate
</span><span class='line'> rake deploy
</span></code></pre></td></tr></table></div></figure>


<p>まだMarkdownがよくわかってない&#8230;</p>
]]></content>
  </entry>
  
</feed>
