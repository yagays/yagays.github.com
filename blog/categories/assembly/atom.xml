<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Assembly | Wolfeyes Bioinformatics beta]]></title>
  <link href="http://yagays.github.com/blog/categories/assembly/atom.xml" rel="self"/>
  <link href="http://yagays.github.com/"/>
  <updated>2012-08-06T22:09:31+09:00</updated>
  <id>http://yagays.github.com/</id>
  <author>
    <name><![CDATA[yag_ays]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[VelvetKを使ってVelvetを用いたアセンブルに最適なk-merサイズを推定する]]></title>
    <link href="http://yagays.github.com/blog/2012/06/06/velvetk/"/>
    <updated>2012-06-06T17:12:00+09:00</updated>
    <id>http://yagays.github.com/blog/2012/06/06/velvetk</id>
    <content type="html"><![CDATA[<p>VelvetKというスクリプトが公開されたらしい．これはVelvetのアセンブルの際にユーザが指定する必要のあるk-merのkの値を，ゲノムサイズとショートリードのサイズから自動推定するスクリプトのようだ．普通ならばkの値を細かく変えてVelvetを大量に走らせてアセンブル結果を評価するというのが定石だと思うが，もしkの値が自動推定できるなら，そのkの値付近だけを重点的に調べるといったことが出来るので大幅に労力を削減できる．私自身あまりVelvet/Oasesを使った経験が無いのだが，取り敢えず一通り使ってみた．</p>

<!-- more -->


<h2>インストール</h2>

<p>インストールは簡単で，Perlスクリプトを落としてくるだけで実行出来る．外部ライブラリの依存が無いのでお手軽．</p>

<p><code>
$ wget http://bioinformatics.net.au/velvetk.pl
</code></p>

<h2>使い方</h2>

<p>VelvetKでkの推定値を算出するには，</p>

<ul>
<li><strong>ゲノム配列</strong> または <strong>ゲノムサイズ</strong></li>
<li><strong>アセンブルの元になるショートリード</strong></li>
</ul>


<p>の2つの入力が必要になる．ゲノム配列が既知の場合には<code>--genome</code>オプションを使って，fasta形式のゲノム配列のファイルを指定する．ショートリードはfastq形式などのファイルを指定することになるが，gzやbz2などの圧縮形式にも対応している．ゲノム配列を指定してVelvetKを実行するには，以下のようにコマンドを実行する．</p>

<p><code>
$ perl velvetk.pl --genome chr.fasta R1.fastq R2.fastq
</code></p>

<p>一方でde novoのようなゲノム配列が無い場合には，対象種のおおまかなゲノムサイズを入力することになる．ゲノムサイズの指定の場合には，k/M/Gといった接頭辞を使う事ができる．ゲノムサイズを数値で指定してVelvetKを実行するには，以下のようにコマンドを実行する．</p>

<p><code>
$ perl velvetk.pl --size=1M chr.fasta R1.fastq R2.fastq
</code>
とする．</p>

<h2>擬似データで試してみる</h2>

<p>今回はお手製の擬似データで試してみることにする．</p>

<p>擬似データの作り方は簡単で，乱数を使って擬似的に作ったゲノム配列からこれまた乱数を使って擬似的にショートリードを作成するというもの．ゲノムの長さを1Mbとして，100bpのペアエンドの配列を500,000本用意して，カバレッジ100xくらいのゲノムシーケンスを想定した．</p>

<p>その擬似データセットで実行してみると以下のような出力が得られた．実際にはショートリードの長さや本数も不均一になるので，以下のように各値が綺麗な感じにはならないと思う．</p>

<p><code>
$ perl velvetk.pl --genome chr.fasta R1.fastq R2.fastq
Estimating target genome size from 'chr.fasta'
Target genome size is 1000000 bp
Desire k-mer coverage of 25
Using cat for R1.fastq
Read 500000 sequences from R1.fastq
Using cat for R2.fastq
Read 500000 sequences from R2.fastq
Considered 1000000 reads with lengths 100..100 bp
K       #Kmers  Kmer-Cov
1       100000000       100.0
3       98000000        98.0
5       96000000        96.0
7       94000000        94.0
9       92000000        92.0
〜〜〜中略〜〜〜
71      30000000        30.0
73      28000000        28.0
75      26000000        26.0
77      24000000        24.0
79      22000000        22.0
81      20000000        20.0
83      18000000        18.0
85      16000000        16.0
87      14000000        14.0
89      12000000        12.0
91      10000000        10.0
93      8000000 8.0
95      6000000 6.0
97      4000000 4.0
99      2000000 2.0
</code></p>

<p>入力ファイルをそれぞれ読み込んだ後，それぞれのkの値に対して#kmersとKmer-Covが表示される．#kmersはショートリードのデータからカウントできるk-merの本数で，例えばK=99の場合では100bpから抜き出せる99merは2つあるので，今回の場合リード数500,000*2の合計2,000,000という感じだろう．次のKmer-Covは，いわゆるK-mer Coverageと呼ばれるもので，実際のカバレッジとk-merで見た時のカバレッジの割合，もしくは変換するときの係数に当たる．</p>

<p>ではどうやってこのリストからVelvetに最適なkの値を推定するかというと，出力の始めの方に書かれている</p>

<p><code>
Desire k-mer coverage of 25
</code></p>

<p>のところを見て，Kmer-Covが25を下回った時のkの値が最適なkの値とする．今回の場合だとk=77でKmer-Covが24.0になるので，k=77が最適なk-merのサイズとなる．</p>

<p>それではなぜ25なのかというと，このスクリプトの場合だとデフォルトだからということになってしまうのだが，どうやらk-mer Coverageにはだいたい10~20あれば十分という知見(多分経験則)があるらしい．一般的にはkの値が小さいとコンティグが繋がりにくく，kの値が大きいと細かな違いをコンティグに反映出来無いといったsensitivityとspecificityのトレードオフがある．それらのいい具合の中間点ということで，k-mer Coverageを見て判断しようということらしい．</p>

<p>また，このスクリプトでは閾値となるk-mer Coverageを変更するオプション<code>--cov</code>や，リストの出力を抜きにして最適なKの値だけを出力するオプション<code>--best</code>なども用意されている．</p>

<p>```
$ perl velvetk.pl --best --cov=20 --size=1M R1.fastq R2.fastq
Target genome size is 1000000 bp
Desire k-mer coverage of 20
Using cat for R1.fastq
Read 500000 sequences from R1.fastq
Using cat for R2.fastq
Read 500000 sequences from R2.fastq
Considered 1000000 reads with lengths 100..100 bp
81</p>

<p>```
 上の場合では，k=81が最適とおもわれるkの推定結果となる．</p>

<h2>実はWeb版もある</h2>

<p>ちなみに，ここまで書いておいて難だが，実はVelvetKと同作者が作った簡易版「Velvet Advisor」がWebアプリケーションとして既に存在している．ただ，この簡易版は複数の入力ファイルに対応していないので，使えるケースが制限されている．普通は複数のライブラリを読んでアセンブルするとと思うので，まあ今回のVelvetKで使いやすくなったという感じだろうか．</p>

<p><a href="http://dna.med.monash.edu.au/~torsten/velvet_advisor/">http://dna.med.monash.edu.au/~torsten/velvet_advisor/</a></p>

<h2>まとめ</h2>

<p>今回は擬似データを使ってVelvetKを動かしてみたが，これからアセンブルをするという人にとってはパラメータの大雑把な目安となって良いと思う．どれだけの精度で当たるのか不安なところもあるので，実際にVelvetを使ったアセンブルのプロジェクトでVelvetKの推定値がどれだけ当たっているかが知りたいところだけれども，結局目安としてしか使わないのだから，まあ適当でいいんだろう．</p>

<h2>参考資料</h2>

<ul>
<li><a href="http://bioinformatics.net.au/software.velvetk.shtml">http://bioinformatics.net.au/software.velvetk.shtml</a></li>
<li><a href="http://kevin-gattaca.blogspot.jp/2012/06/fwd-velvet-users-velvetkpl-choose-good.html">http://kevin-gattaca.blogspot.jp/2012/06/fwd-velvet-users-velvetkpl-choose-good.html</a></li>
<li><a href="http://dna.med.monash.edu.au/~torsten/velvet_advisor/">http://dna.med.monash.edu.au/~torsten/velvet_advisor/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ALLPATHS-LGを最小構成で実行する]]></title>
    <link href="http://yagays.github.com/blog/2012/06/04/allpaths-lg-introduction/"/>
    <updated>2012-06-04T13:08:00+09:00</updated>
    <id>http://yagays.github.com/blog/2012/06/04/allpaths-lg-introduction</id>
    <content type="html"><![CDATA[<p><a href="http://yagays.github.com/blog/2012/06/02/allpaths-lg-dataset/">前回</a>は，ALLPATHS-LGの入力データの制約についてFragment LibraryとJumping Libraryの2つが最低でも必要ということを書いたが，今回は実際にALLPATHS-LGを動かすところを見ていく．ただし，複雑で込み入った細かい部分は分からないので，最小構成でとにかくアセンブル結果を得るということだけを解説していこうと思う．</p>

<!-- more -->


<p>今回はALLPATHS-LGのexampleを使って解説していく．このexampleにはprepare.shとassemble.shという2つのシェル・スクリプトが付属しており，これらを動かせばアセンブルは実行できるのだが，今回は最小構成で実行するということで，これらの用意されたスクリプトを使わず直にコマンドを叩いて動かしていこうと思う．ALLPATHS-LGパイプラインの特徴である美しいディレクトリ構成などは一切無視して進むので，もし上手に実験を組んでディレクトリ構成を管理したい場合はマニュアルを熟読していただきたい．</p>

<h3>概要</h3>

<p>まず，ALLPATHS-LGを動かすために必要なステップが3つある．</p>

<ol>
<li><strong>in_groups.csvとin_libs.csvを作る</strong></li>
<li><strong>PrepareAllPathsInputs.plを実行する</strong></li>
<li><strong>RunAllPathsLGを実行する</strong></li>
</ol>


<p>最低限この3つを実行すれば，アセンブル結果が出てくる．では個別に見てこう．</p>

<h3>in_groups.csvとin_libs.csvを作る</h3>

<p>ALLPATHS-LGでは，入力となるNGSデータの情報をin_groups.csvとin_libs.csvの2つに記述する必要がある．</p>

<p>in_groups.csvでは，アセンブルの元データとなるNGS入力データの場所と種類，そしてライブラリの名前をコンマ区切りのテキストとして保存する．exampleのin_groups.csvは以下のようになっている．</p>

<p>```
$ cat in_groups.csv</p>

<pre><code>    file_name, library_name, group_name
</code></pre>

<p>seq/frags.?.fastq, Solexa-25396,      frags
seq/jumps.?.fastq, Solexa-11542,      jumps
```</p>

<p>file_nameは入力データのパスを指定する．相対パスでも絶対パスでも問題ない．入力ファイルがペアエンドなどで対になっている場合は<strong><code>?</code></strong>や<strong><code>*</code></strong>のワイルドカードを使う必要があり，例えばR1.fastqとR2.fastqなら"R?.fastq"とすれば2つのファイルをひとまとまりとして認識できる．次にlibrary_nameとgroup_nameだが，これらは入力データを区別するためにユーザが指定する項目で，自由に名前を付けることができる．library_nameは後述のin_libs.csvでも共通して使われるので，そちらの配列情報の項目と名前を合わせる必要がある．また，group_nameはそれぞれの配列データにユニークな名前を付ける必要がある．上の例ではfragsとjumpsとなっているが，これはライブラリの種類を指定しているわけではなく，ただ名前を付けているだけなので勘違いしないように注意が必要である．</p>

<p>次に，in_libs.csvでは，アセンブルの元データとなるNGS入力データのライブラリの種類とインサートサイズなどの各情報をコンマ区切りのテキストとして保存する．exampleのin_libs.csvは以下のようになっている．</p>

<p><code>
$ cat in_libs.csv
library_name, project_name, organism_name,     type, paired, frag_size, frag_stddev, insert_size, insert_stddev, read_orientation, genomic_start, genomic_end
Solexa-25396,         test,   test.genome, fragment,      1,       180,          10,            ,              ,           inward,             0,           0
Solexa-11542,         test,   test.genome,  jumping,      1,          ,            ,        3000,           500,          outward,             0,           0
</code>
まず一番左のカラムには，先ほどのin_groups.csvで指定したlibrary_nameと同じものを入力する．そして，それ以降の行で詳しいライブラリの情報を指定していく．project_nameやorganism_nameなどはユーザが自由に名前を付ける事ができる．それ以降のtypeやpaired，frag_sizeなどではライブラリの情報を入力していくが，関係ない項目は空白にしておいて良い．このあたりの入力情報の詳細はマニュアルに詳しく記載されているので，そちらを参照されたい．</p>

<p>さて，in_groups.csvとin_libs.csvが揃ったところで，次からいよいよALLPATHS-LGを動かしていく．</p>

<h3>PrepareAllPathsInputs.plを実行する</h3>

<p>さて，ここから実際にALLPATHS-LGを動かしていくわけだが，まずはPrepareAllPathsInputs.plというスクリプトを動かして，パイプラインのディレクトリ作成や入力データの変換などを行う．</p>

<p>それでは実際にPrepareAllPathsInputs.plを動かしてみよう．先ほどのin_groups.csvとin_libs.csvがあるディレクトリで，以下のコマンドを実行する．</p>

<p><code>
PrepareAllPathsInputs.pl DATA_DIR=$PWD PLOIDY=2  
</code></p>

<p>最低限必要なのはDATA_DIRとPLOIDYの2つだけである．DATA_DIRはアセンブル結果を保存するディレクトリを指定するオプションで，今回は最小構成ということで，このスクリプトを動かしたディレクトリ以下に結果を置くようにする．PLOIDYではゲノムアセンブリの対象種における倍数を指定する．1倍体なら1，2倍体なら2という具合だが，現在のところALLPATHS-LGは2倍体以上の倍数体には対応していないようだ．なお，マニュアルには他にもオプションが指定されているが，PICARD_TOOLS_DIRは入力ファイルがbamファイルでなければ必要ない．</p>

<h3>RunAllPathsLGを実行する</h3>

<p>入念な下準備が終わったところで，いよいよALLPATHS-LGの本体を動かす．まずは実行コマンドを見てみよう．</p>

<p><code>
RunAllPathsLG PRE=. REFERENCE_NAME=. DATA_SUBDIR=. RUN=allpaths SUBDIR=run  
</code></p>

<p>色々とオプションが指定されているが，これらは全てディレクトリに関するものである．PREやREFERENCE_NAME，DATA_SUBDIRで指定されているドットは「現在のディレクトリ」を表している．RUNやSUBDIRは出力結果のが置かれるディレクトリの名前になり，上のコマンドの場合には，final.assembly.fastaなどのアセンブル結果はallpaths/ASSEMBLIES/runのディレクトリ以下に置かれることになる．マニュアルではTARGETSというオプションがあるが，これは既にゲノムが読まれていたりする場合に，それをリファレンスとして使うことでALLPATHS-LGのアセンブル結果と比較してまとめて評価してくれるというものである．今回は使用していないので関係無いが，exampleではリファレンスゲノムもきちんと用意されているので，試すことはできる．</p>

<h3>まとめ</h3>

<p>ということで，足早にALLPATHS-LGの使い方を最小構成で見てきた．こうやって並べてみると，実際にアセンブルに必要な項目というのは非常に少なく，in_groups.csvとin_libs.csv，そしてPLOIDYさえ指定すればアセンブルすることはできる事がわかる．まあ実際に動かすとアセンブルが上手くいかない部分は多々出てくると思うが，最小構成で一度実行できてさえいれば次からはパラメータチューニングをしていくだけなので，アセンブル結果の評価と並行して進めることができる．ALLPATHS-LGでは他にも様々な種やデータに対応できるよう色々とオプションが用意されているので，色々試してみると面白かもしれない．</p>

<h3>参考サイト</h3>

<ul>
<li><a href="http://www.broadinstitute.org/software/allpaths-lg/blog/">http://www.broadinstitute.org/software/allpaths-lg/blog/</a></li>
<li><a href="http://evomics.org/wp-content/uploads/2012/01/Allpaths_exercises.pdf">http://evomics.org/wp-content/uploads/2012/01/Allpaths_exercises.pdf</a></li>
<li><a href="http://evomics.org/learning/assembly-and-alignment/allpaths-lg/">http://evomics.org/learning/assembly-and-alignment/allpaths-lg/</a></li>
<li>(pdf) <a href="http://evomics.org/wp-content/uploads/2012/01/Allpaths_exercises.pdf">http://evomics.org/wp-content/uploads/2012/01/Allpaths_exercises.pdf</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ALLPATHS-LGで使用できるライブラリサイズの制限]]></title>
    <link href="http://yagays.github.com/blog/2012/06/02/allpaths-lg-dataset/"/>
    <updated>2012-06-02T15:52:00+09:00</updated>
    <id>http://yagays.github.com/blog/2012/06/02/allpaths-lg-dataset</id>
    <content type="html"><![CDATA[<p>ALLPATHS-LGは複数のライブラリで読まれたショートリードを組み合わせてゲノムアセンブルをするソフトウェア（パイプライン）である．比較的新しいゲノムアセンブラで性能もかなり良いらしく，<a href="http://www.broadinstitute.org/software/allpaths-lg/blog/">公式ブログ</a>のアセンブル履歴を見ると非モデル生物を中心にかなり使われている印象がある．ただ，その反面かなり癖のあるソフトウェアで，インストールが鬼門・動かすのが難しい・インターネットに資料が少ないという三重苦で，初心者にはかなりハードルの高いソフトウェアと言わざるを得ない．その中でも個人的に一番やっかいだと思うポイントはパイプライン入力に使うデータセットの準備で，折角苦労してALLPATHS-LGが使える環境を整えたとしても，使えるデータが無いとそもそも動かないということになりかねない．</p>

<p>ということで，今回はALLPATHS-LGを動かすために必要なライブラリについて見ていく．私自身も厳密に調べたわけではないので間違い等あるかもしれないが，もし詳しい方がいらっしゃればご指摘頂ければ幸い．</p>

<p> <!-- more --></p>

<p>まず，ALLPATHS-LGが想定してるNGSショートリードは，長さ~100bp程度のペアエンドである．454のロングリードなどには対応していないようだが，最近のバージョンアップでillumina+PacBioのハイブリッドアセンブルが出来るようになっているらしい（<a href="http://www.broadinstitute.org/software/allpaths-lg/blog/?p=463">url</a>）．</p>

<p>ここまでは問題無いのだが，次のペアエンドのライブラリの種類に関する条件が非常に複雑である．まずALLPATHS-LGでは，ショートリードのライブラリは以下の3つに区分される．</p>

<ul>
<li>Fragment Library (Short Library)</li>
<li>Jumping Library (long Library)</li>
<li>Long Jumping Library</li>
</ul>


<p>このうち，アセンブルに必要となるライブラリはFragment LibraryとJumping Libraryである．ここで重要なのは，<strong>どちらも必ず最低1つ</strong>は必要になるということである．たとえFragment Libraryがいくつあっても，Jumping LibraryがなければALLPATHS-LGは動かない．これが非常に重要で，後述のライブラリの条件で詳しく述べるが，Jumping LibraryのInsert sizeには制限があるため，これをクリアするデータを持っていない場合はそもそもALLPATHS-LGを動かす事ができない．</p>

<h2>Fragment Library</h2>

<p>ではそれぞれのライブラリの条件を順に見ていこう．まずFragment Libraryだが，これはインサートサイズの短い配列のことを指す．ただこれには制約があり，ペアエンドの読まれたリードが重なっている必要がある．これだけでは何のことか分からないと思うので例を使って説明すると，例えば100bpのペアエンドの場合では両端から100bpずつ読まれるので，それらが重なるようなインサートサイズを考えると，200bp以下である必要がある．もしインサートサイズが300bpの場合では両端のリードの間に隙間が出来てしまうので，このライブラリはFragment Libraryにはならない．実際にはインサートサイズは少しばらつきがあり，ALLPATHS-LGでもインサートサイズの値に加えて標準偏差stddevも指定できるようになっているが，基本的にペアエンドリードが重なるような長さのものを使う必要がある．</p>

<h2>Jumping Library</h2>

<p>次にJumping Libraryである．ALLPATHS-LGではインサートサイズが3,000bp〜10,000bp程度のライブラリを想定している．ただしこれにも制約があり，ペアエンドリード間の長さ(separation size)が最低1,000bp以上ないとJumping Libraryと見なされない．ということは，100bpのペアエンドの場合，Jumping Libraryとして認識されるには最低1,200bp程度のインサートサイズが必要となる．これが非常にややこしいところで，Fragment Libraryより長いインサートはJumping Libraryになるかというと，そうでもないのである．じゃあ100bpペアエンドリードでインサートサイズが200bp〜1000bpの間のライブラリはどれに分類されるかというと，これが非常に謎な部分で私自身もあまり良くわかっていない．これらのインサートサイズのライブラリはFragment LibraryとしてALLPATHs-LGの入力ファイルに登録することは出来る(Validationに通る)ので，使われないことは無いと思う．ただし，このFragment Libraryモドキ単体だけではFragment Libraryが不足しているとしてALLPATHS-LGを動かすことが出来無いので，最低でも200bp以下のオーバーラップしているライブラリと組み合わせて使う必要がある．謎い．</p>

<h2>Long Jumping Library</h2>

<p>最後にLong Jumping Libraryだが，マニュアルによるとインサートサイズが20kbpsのライブラリを想定しているらしい．前述のJumping Libraryにおいてペアエンドリード間の長さの上限が10kbpなので，それ以上はLong Jumping Libraryとしても良さそうである．</p>

<p><img src="http://dl.dropbox.com/u/142306/b/allpaths-lg-dataset.png" alt="Fragment LibraryとJumping Libraryの模式図" /></p>

<p>といった感じでALLPATHS-LGを動かすために必要なライブラリの種類を見てきた．結論としては兎に角動かすためのデータセットの制限がシビアということで，データのライブラリサイズなどの情報をきちんと把握しておく必要がある．まあデータが揃っていたとしてもALLPATHS-LGを動かすのも一苦労なのだが，この話はまた別の機会に書ければ書くことにする．というか自分も理解していないところが多いので手探り感が強いが...．</p>

<hr />
]]></content>
  </entry>
  
</feed>
